<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>陈年风楼 | 博客</title>
  
  <subtitle>当你看到了一座山，一定会想再看看山的后面是什么！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangjiaheng.cn/"/>
  <updated>2019-11-24T12:34:29.048Z</updated>
  <id>http://zhangjiaheng.cn/</id>
  
  <author>
    <name>陈年风楼</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scaffold-Cloud —— SpringCloud微服务架构实践</title>
    <link href="http://zhangjiaheng.cn/blog/20191112/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%AE%9E%E8%B7%B5/"/>
    <id>http://zhangjiaheng.cn/blog/20191112/SpringCloud微服务架构实践/</id>
    <published>2019-11-12T05:42:24.000Z</published>
    <updated>2019-11-24T12:34:29.048Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20191112/SpringCloud微服务架构实践/scaffold.png" alt="scaffold"></p><center><u style="font-size=8px; color:gray">Scaffold-Cloud SpringCloud微服务脚手架</u></center><a id="more"></a><h2 id="什么是Scaffold-Cloud？–-幕布"><a href="#什么是Scaffold-Cloud？–-幕布" class="headerlink" title="什么是Scaffold-Cloud？– 幕布"></a>什么是Scaffold-Cloud？– <a href="https://mubu.com/doc/6NZlNw3DIw" target="_blank" rel="noopener">幕布</a></h2><p>Scaffold-Cloud 是一个适用于开发者学习的 Spring-Cloud 微服务项目脚手架。项目期望集成大部分目前互联网公司使用的主流的Spring-Cloud微服务相关工具和服务。并结合一些实际的业务增加一些其他功能，如：分布式事务、定时任务、消息队列、日志分析等等。</p><p>Scaffold-Cloud 基于 SpringCloud NetFlix 全家桶进行微服务项目的构建，所以在这之前，使用 Scaffold-Cloud 需要先了解 Spring Cloud NetFlix 提供的一系列的 SpringCloud 框架。</p><p><img src="/blog/20191112/SpringCloud微服务架构实践/netflix.png" alt></p><center><u style="font-size=6px; color:gray">Sorry, NetFlix is not available in your country yet.</u></center><h2 id="Spring-Cloud-介绍"><a href="#Spring-Cloud-介绍" class="headerlink" title="Spring Cloud 介绍"></a>Spring Cloud 介绍</h2><h4 id="从单体应用到微服务"><a href="#从单体应用到微服务" class="headerlink" title="从单体应用到微服务"></a>从单体应用到微服务</h4><p>在早期的企业中，项目基本上都是单体应用，将一个网站部署在一台单独的服务器上对用户提供服务。但是这样的服务最大的缺点就是，当服务器断电或者服务进程挂掉，用户直接就无法访问。后来演进出集群服务，将同样的服务在多台服务器分别部署，使用负载均衡等手段让服务对于用户来说看到的都是同一个，这样当一台服务器夯机至少还有其他的服务器提供相同的应用。</p><p>但是，当企业级服务变得越来越复杂的时候，项目变得越来越庞大，有时甚至影响到了服务的部署，这个时候就应该将庞大的服务拆分成多个子系统，部署在不同的服务器上，这样的服务当遭遇高并发访问的时候也能够将请求压力分摊到多个服务器上，这就是分布式。</p><p>而当企业需要开启一个新的项目时，为了避免重复造轮子，往往一些可复用的模块会被拆分出来作为一个微小的系统，它可以独立的开发、设计、运行和运维，只需要使用 ESB企业服务总线将所有服务整合并提供统一的访问入口，就能够复用，这就是 SOA。</p><p>而微服务是对以上服务架构的最终演进结构：将服务切分成多个微小的应用，提供统一的服务访问协议HTTP(SpringCloud)/TCP(Dubbo)，强调运行时的分散解耦，在业务上也有着高度的抽离。</p><p><strong>但是拆分成这么微小的微服务一定会碰到各种各样的问题——如何拆分？服务之间如何发现？如何授权？如何做负载均衡？如何管理多服务配置？如何跟踪调用链路？如何实时查看服务状态等等… … SpringCloud 就是以上一系列问题的 Solver。它提供了一整套的解决方案！</strong></p><h4 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h4><p>首先，SpringCloud 并不是一个框架，而是一系列微服务框架的集合，或者说一个微服务的规范。</p><h3 id="SpringCloudNetFlix-全家桶"><a href="#SpringCloudNetFlix-全家桶" class="headerlink" title="SpringCloudNetFlix 全家桶"></a>SpringCloudNetFlix 全家桶</h3><h2 id="项目创建的目的？"><a href="#项目创建的目的？" class="headerlink" title="项目创建的目的？"></a>项目创建的目的？</h2><p>第一个目的是为了本人能够熟悉和学习 Spring-Cloud 相关知识，不过在做了一段时间之后还是希望能够分享出来让更多的同学一起学习和讨论。</p><h2 id="项目结构如何？"><a href="#项目结构如何？" class="headerlink" title="项目结构如何？"></a>项目结构如何？</h2><h2 id="项目已经集成了哪些功能？"><a href="#项目已经集成了哪些功能？" class="headerlink" title="项目已经集成了哪些功能？"></a>项目已经集成了哪些功能？</h2><ul><li><a href="[http://zhangjiaheng.cn/blog/20190819/%E5%A6%82%E4%BD%95%E5%9C%A8Spring%20Cloud%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Rocket%20MQ/](http://zhangjiaheng.cn/blog/20190819/如何在Spring Cloud中优雅的使用Rocket MQ/">RocketMQ</a>)</li><li><a href="[http://zhangjiaheng.cn/blog/20190806/%E6%88%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9ALCN/](http://zhangjiaheng.cn/blog/20190806/我项目中使用的分布式事务：LCN/">分布式事务</a>)</li><li>可视化JOB</li></ul><h2 id="如何快速开始？"><a href="#如何快速开始？" class="headerlink" title="如何快速开始？"></a>如何快速开始？</h2><h3 id="1-本地直接启动"><a href="#1-本地直接启动" class="headerlink" title="1. 本地直接启动"></a>1. 本地直接启动</h3><h4 id="1-1-所需环境"><a href="#1-1-所需环境" class="headerlink" title="1.1 所需环境"></a>1.1 所需环境</h4><h4 id="1-2-启动流程-顺序"><a href="#1-2-启动流程-顺序" class="headerlink" title="1.2 启动流程/顺序"></a>1.2 启动流程/顺序</h4><h3 id="2-使用-docker-部署"><a href="#2-使用-docker-部署" class="headerlink" title="2. 使用 docker 部署"></a>2. 使用 docker 部署</h3><h2 id="项目未来还需要做什么？"><a href="#项目未来还需要做什么？" class="headerlink" title="项目未来还需要做什么？"></a>项目未来还需要做什么？</h2><hr><h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4><blockquote><p><a href="https://juejin.im/post/5c28f2fe51882565a15776fb" target="_blank" rel="noopener">https://juejin.im/post/5c28f2fe51882565a15776fb</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20191112/SpringCloud微服务架构实践/scaffold.png&quot; alt=&quot;scaffold&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;u style=&quot;font-size=8px; color:gray&quot;&gt;Scaffold-Cloud SpringCloud微服务脚手架&lt;/u&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="SpringCloud" scheme="http://zhangjiaheng.cn/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://zhangjiaheng.cn/tags/SpringCloud/"/>
    
      <category term="微服务" scheme="http://zhangjiaheng.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="SpringBoot" scheme="http://zhangjiaheng.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发DDD/TDD/Right-BICEP/CORRECT/SOLID相关理解与总结</title>
    <link href="http://zhangjiaheng.cn/blog/20191031/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91DDD-TDD-Right-BICEP-CORRECT-SOLID%E7%9B%B8%E5%85%B3%E7%90%86%E8%A7%A3%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://zhangjiaheng.cn/blog/20191031/敏捷开发DDD-TDD-Right-BICEP-CORRECT-SOLID相关理解与总结/</id>
    <published>2019-10-31T13:34:56.000Z</published>
    <updated>2019-11-24T13:01:08.273Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20191031/敏捷开发DDD-TDD-Right-BICEP-CORRECT-SOLID相关理解与总结/fm.jpg" alt></p><a id="more"></a><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><h4 id="什么是敏捷开发？"><a href="#什么是敏捷开发？" class="headerlink" title="什么是敏捷开发？"></a>什么是敏捷开发？</h4><p>​    在以往传统的软件开发模式中，我们通常使用的都是一种瀑布式的开发流程。那我之前工作过的两家公司来举例子吧。之前的公司组织结构分为一个项目经理BA，产品经理PM，技术组长TL，开发人员DEV，测试人员QA，项目通常是项目经理和客户沟通好一整个产品之后，由产品经理画出设计稿，最后开发评审，着手开发，最后测试通过后运维部署上线。这样的产品需要在一开始就确定所有需求，等到开发结束之后，才能看到最终的效果。一旦开发的过程中有需求的改动而客户必须要求修改时，万一开发人员在设计的时候没有考虑周全，有可能一个很小的地方的改动就会引起大规模的代码重构！而在于敏捷开发中呢，项目成员会尽可能的将项目进行细分，基于DDD把一整块大的需求切分成很小的模块，开发人员每次在足够小的需求上进行迭代开发。这样的软件开发模式足以应对非常频繁的需求变更以及同时能够保证软件开发质量。敏捷开发中有一个敏捷宣言，它规定了项目开发过程中几个方向的优先级，如下：</p><table><thead><tr><th>高优先级</th><th>低优先级</th></tr></thead><tbody><tr><td>个体与交互</td><td>流程与工具</td></tr><tr><td>客户协作</td><td>合同谈判</td></tr><tr><td>响应变化</td><td>遵循计划</td></tr><tr><td>可工作的软件</td><td>面面俱到的文档</td></tr></tbody></table><h4 id="为什么要使用敏捷开发这种模式？"><a href="#为什么要使用敏捷开发这种模式？" class="headerlink" title="为什么要使用敏捷开发这种模式？"></a>为什么要使用敏捷开发这种模式？</h4><p>​    敏捷开发的核心就是<code>在一个高度协作的环境下，不断的通过反馈来进行自我调整和完善</code>。重点强调的是<code>协作</code>和<code>反馈</code>，协作体现在团队与客户之间的协作，团队成员之间的协作。反馈则是在开发中的任何环节，包括代码质量、自动化测试、部署、项目进度、需求变更、客户验收等，而且反馈越快越好。有句土耳其谚语这么讲的：<code>&quot;不管你走了多远，错了就要重新返回&quot;</code>，所以我们越快得到反馈，就能越早确认自己有没有走错路。如果没有错，我们会更加充满信心。反之，及时做出调整，让成本最小化。总之使用敏捷开发的软件开发模式，能够让我们少走弯路，应对多变的客户需求。</p><h2 id="敏捷开发相关的开发、设计原则与测试规范"><a href="#敏捷开发相关的开发、设计原则与测试规范" class="headerlink" title="敏捷开发相关的开发、设计原则与测试规范"></a>敏捷开发相关的开发、设计原则与测试规范</h2><h3 id="SOLID-原则"><a href="#SOLID-原则" class="headerlink" title="SOLID 原则"></a>SOLID 原则</h3><blockquote><p>  这个其实是设计模式的原则或者说其主要思想，一般国内互联网公司面试也都会遇到的问题</p></blockquote><h4 id="S（SRP"><a href="#S（SRP" class="headerlink" title="S（SRP"></a>S（SRP</h4><p>单一职责：一个类在任何时候都只应该完成某一种职责或者功能，不应该将复杂的功能都编写在同一个类中。当类的使用者在使用这个类的时候一看到这个类就会联想到对应的功能，而且软件的维护者不需要对一个类维护太多的功能。</p><h4 id="O（OCP"><a href="#O（OCP" class="headerlink" title="O（OCP"></a>O（OCP</h4><p>开闭原则：一个类或者软件实体应该开放扩展，关闭修改。也就是说对扩展开放，对修改关闭。类的使用者在</p><h4 id="L（LSP"><a href="#L（LSP" class="headerlink" title="L（LSP"></a>L（LSP</h4><p>里式替换：一个类的所有功能都能够替换其所有父类。或者说接口出现的地方实现类都能够出现并完成功能。一般来讲这一点对所有面向对象语言都适用。</p><h4 id="I（ISP"><a href="#I（ISP" class="headerlink" title="I（ISP"></a>I（ISP</h4><p>接口隔离：每个接口不应该存在子类用不到却必须实现的方法。听起来和第一点单一职责有点像，但是这个是说的针对子类的实现关系，而单一职责说的是针对当前类或者软件。</p><h4 id="D（DIP"><a href="#D（DIP" class="headerlink" title="D（DIP"></a>D（DIP</h4><p>依赖倒置：就是面向接口编程。一个模块依赖于另一个模块的抽象而不是其具体实现。这样的好处是可以实现多态，不同的子类的不同实现在运行期绑定。</p><h4 id="最后还有个【最少知道（迪米特法则）】："><a href="#最后还有个【最少知道（迪米特法则）】：" class="headerlink" title="最后还有个【最少知道（迪米特法则）】："></a>最后还有个【最少知道（迪米特法则）】：</h4><p>一个类对于自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将复杂的业务逻辑封装在被依赖类的内部，使暴露出的功能单一化。</p><h3 id="Riht-BICEP原则-单元测试相关"><a href="#Riht-BICEP原则-单元测试相关" class="headerlink" title="Riht-BICEP原则[单元测试相关]"></a>Riht-BICEP原则[单元测试相关]</h3><blockquote><p>  在以往的公司，自己的职位是后台开发，那平时工作中也都只是在做【后台开发】做的事情，对于测试的工作都留给测试人员去做，自己一概不知也没有做过相应的学习。现在来到一个敏捷开发团队，系统的进行测试也成为一个deve的工作职责。而在这一方面要学习的第一个测试的原则，就是Riht-BICEP原则。</p></blockquote><h4 id="Right-结果是否正确"><a href="#Right-结果是否正确" class="headerlink" title="Right: 结果是否正确"></a>Right: 结果是否正确</h4><p>最简单的，查看是否是预期结果。</p><h4 id="B-Boundary-边界检测是否正确"><a href="#B-Boundary-边界检测是否正确" class="headerlink" title="B:Boundary,边界检测是否正确"></a>B:Boundary,边界检测是否正确</h4><p>边界是单元测试中最需要考虑的地方，也是开发中最容易忽略和BUG最容易产生的地方。以下是需要考虑的几个边界条件：</p><ol><li>空值</li><li>越界问题，如月份不大于12，小时不大于24，及其他需要考虑的越界问题</li><li>是否含有违反常理的字符，例如文件名中含有乱码或者特殊字符<img src="C:/Users/zhang/Desktop/Users/jiaheng.zhang/Library/Application%20Support/typora-user-images/image-20191024172031586.png" alt="image-20191024172031586"></li><li>格式错误。例如手机号违反设计常理、邮箱、护照证件号码等等</li><li>不应该出现重复的数组中出现了重复值</li><li>是否已经就位或者满足执行条件。例如在文件生成之前执行打印操作就是不满足的。</li></ol><h4 id="I-inverse-调整顺序是否正确"><a href="#I-inverse-调整顺序是否正确" class="headerlink" title="I:inverse,调整顺序是否正确"></a>I:inverse,调整顺序是否正确</h4><p>即交叉测试，用不同的方式或者顺序得出结果然后再比较。</p><h4 id="C-cross-check：环形测试"><a href="#C-cross-check：环形测试" class="headerlink" title="C:cross-check：环形测试"></a>C:cross-check：环形测试</h4><p>一些功能需要在环形测试中去验证正确性，例如计算4的平方根，用两个计算结果相乘和4比较。实际点的例子比如在数据库中插入数据然后再query。</p><h4 id="E-error-condition：-异常情况"><a href="#E-error-condition：-异常情况" class="headerlink" title="E:error-condition： 异常情况"></a>E:error-condition： 异常情况</h4><p>在实际生产环境中，会出现很多测试或者开发中遇不到的异常情况，例如断网，硬盘爆满等，基于服务高可用的需求，考虑以下一些情况：</p><ol><li>内存溢出</li><li>空间不足</li><li>时钟混乱</li><li>网络不可达</li></ol><h4 id="p-performance-性能曲线"><a href="#p-performance-性能曲线" class="headerlink" title="p:performance : 性能曲线"></a>p:performance : 性能曲线</h4><p>要考虑随着用户量的增加，服务性能是否会受到影响。</p><h4 id="CORRECT"><a href="#CORRECT" class="headerlink" title="CORRECT"></a>CORRECT</h4><p>正确性测试</p><h4 id="TDD-FIRST-TEST-DRIVEN-DEVELOPMENT"><a href="#TDD-FIRST-TEST-DRIVEN-DEVELOPMENT" class="headerlink" title="TDD-FIRST(TEST DRIVEN DEVELOPMENT)"></a>TDD-FIRST(TEST DRIVEN DEVELOPMENT)</h4><p>测试驱动开发：用测试去驱动开发，在开发功能代码之前，先编写单元测试代码。是敏捷开发模式中的一种设计方法论。</p><h3 id="DDD-Domain-Driven-Design"><a href="#DDD-Domain-Driven-Design" class="headerlink" title="DDD(Domain-Driven Design)"></a>DDD(Domain-Driven Design)</h3><p>DDD（Domain-Driven Design 领域驱动设计）即对软件所涉及到的领域进行建模。我对这一块还没有做过多的学习，更详细的参照一篇博客：</p><blockquote><p>   <a href="https://www.jianshu.com/p/b0379067c978" target="_blank" rel="noopener">DDD 极简教程</a></p></blockquote><p><img src="/blog/20191031/敏捷开发DDD-TDD-Right-BICEP-CORRECT-SOLID相关理解与总结/ddd.webp" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20191031/敏捷开发DDD-TDD-Right-BICEP-CORRECT-SOLID相关理解与总结/fm.jpg&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="敏捷开发" scheme="http://zhangjiaheng.cn/categories/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="敏捷开发" scheme="http://zhangjiaheng.cn/tags/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    
      <category term="DDD" scheme="http://zhangjiaheng.cn/tags/DDD/"/>
    
      <category term="TDD" scheme="http://zhangjiaheng.cn/tags/TDD/"/>
    
      <category term="CORRECT" scheme="http://zhangjiaheng.cn/tags/CORRECT/"/>
    
      <category term="Right-BICEP" scheme="http://zhangjiaheng.cn/tags/Right-BICEP/"/>
    
      <category term="SOLID" scheme="http://zhangjiaheng.cn/tags/SOLID/"/>
    
  </entry>
  
  <entry>
    <title>间隔了一月的博客</title>
    <link href="http://zhangjiaheng.cn/blog/20190919/%E9%97%B4%E9%9A%94%E4%BA%86%E4%B8%80%E6%9C%88%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <id>http://zhangjiaheng.cn/blog/20190919/间隔了一月的博客/</id>
    <published>2019-09-19T15:56:21.000Z</published>
    <updated>2019-11-01T01:40:48.262Z</updated>
    
    <content type="html"><![CDATA[<h4 id="不要让养成没多久的习惯轻易地中断"><a href="#不要让养成没多久的习惯轻易地中断" class="headerlink" title="不要让养成没多久的习惯轻易地中断"></a>不要让养成没多久的习惯轻易地中断</h4><p>今天看了下我上一篇技术博客的时间是一月之前，还是只完成一半的文章，想抽死自己。前几个月我一边准备着面试刷着面试题，一边将整理学习的知识发布在个人博客上。因为之前一个月在准备换工作忙着跑面试，博客被我给中断掉了。这可是我“逼迫”自己养成的一个习惯啊！千万不能松懈！</p><p>最近几天准备离开杭州的一些事宜，间隙中都会打开电脑玩起游戏。实在是太过于放松了以至于一点儿技术都没有学习！实在是不应该。连过几天出去玩的心情都没有了。</p><p>也许可以考虑下边去一个陌生的地方看看，边在那里敲敲代码学学习~ 比如说去什么云南大理、丽江什么的，找个小酒馆的角落，坐在那里敲着代码哈哈哈 hhhhhh… …</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;不要让养成没多久的习惯轻易地中断&quot;&gt;&lt;a href=&quot;#不要让养成没多久的习惯轻易地中断&quot; class=&quot;headerlink&quot; title=&quot;不要让养成没多久的习惯轻易地中断&quot;&gt;&lt;/a&gt;不要让养成没多久的习惯轻易地中断&lt;/h4&gt;&lt;p&gt;今天看了下我上一篇技术博客的
      
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>其实我不太想离开这里</title>
    <link href="http://zhangjiaheng.cn/blog/20190909/%E5%85%B6%E5%AE%9E%E6%88%91%E4%B8%8D%E6%83%B3%E7%A6%BB%E5%BC%80%E8%BF%99%E9%87%8C/"/>
    <id>http://zhangjiaheng.cn/blog/20190909/其实我不想离开这里/</id>
    <published>2019-09-09T14:01:04.000Z</published>
    <updated>2019-11-01T01:40:48.216Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190909/其实我不想离开这里/fm.png" alt="杭州西湖"></p><a id="more"></a><h4 id="序"><a href="#序" class="headerlink" title="序"></a>序</h4><p>我要离开了。离开杭州，离开这个生活了快三年的地儿。放弃要去一线大公司的欲望，放弃年薪百万的梦想，放弃温柔可爱的南方姑娘，放弃我毕业之前一直向往的自由和远方… … 最让我难受的，在杭州两年认识的几个朋友，也许以后再难见上一面。还有，回到了家乡，我是否就此过上一个安逸的生活，还能否保持目前的这份斗志。杭州被程序员论坛称为“奋斗逼之都”，源于马老师的福报，我虽不喜欢这种996的工作节奏，但是离开这里，真的要放弃很多。</p><h4 id="辞职"><a href="#辞职" class="headerlink" title="辞职"></a>辞职</h4><p>2019年8月21日，在被称为互联网寒冬的这年，我辞职了。因为这一年以来，公司的经营状况出了很大的问题，8月，线上服务器关闭了，这意味着理财业务此时已经完全停止，公司金融部门用仅剩的海外贷款业务维持着最后一线生机。这种时刻，但凡是觉得自己在离开之后能够找到合适工作的人，都不会想要再继续再公司呆下去。我就是其中之一，所以我向老大说，我想走了！</p><p>后来，我们一起去吃了散伙饭，又是火锅，每次都是。为什么说“每次”呢？因为在我之前，还有5个人。我想我也不会是最后一个吧。</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>事实上半年以来我都在使用空闲时间学习、刷算法题、写博客、点亮GitHub绿点以期望自己在之后找工作能够靠着博客和GitHub的活跃程度吸引到某公司的面试官（后来事实证明，这个做法还挺管用，当然我的确有在丰富自己的知识而不只是点“绿点”）。这半年以来，在公司所做的工作几乎可以用杂活来形容！不过这些杂活，为我营造了充足的学习时间的同时，却也让我后来的简历上难以写上一些有含金量的项目。</p><p>今年以来，我写了大概30多篇博客，有段时间几乎是一周两篇，就在公司用上班时间写！博客主要学习和整理一些Java基础、多线程并发编程系列的知识，以及整理一些我在实际项目中的一些需求的解决方案。除了博客，我还在GitHub整理了自己在公司使用的一些基础框架，然后自己搭建了一个spring cloud版本的脚手架：<a href="https://github.com/Fatezhang/scaffold-cloud" target="_blank" rel="noopener">Scaffold-Cloud</a>。还在幕布上整理了大篇幅的<a href="https://mubu.com/doc/hpBd1e5h6z" target="_blank" rel="noopener">Java学习大纲</a>和一些面试题目、Java知识点、阿里Java开发手册，不过到目前还没有整理完成，因为实在是太多了，Java基础、设计模式、数据结构与算法、分布式、数据库、计算机网络等等，一点点敲下来也是非常费时间的。</p><h4 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h4><p>说了这么多，你可能以为离职之后我找到了一个好工作。然而，在离职后的一周，我在某直聘APP上投递了几十家简历，在八月的最后一周，我面试了五家公司，包括一家仅有电话面试的公司。事实上在面试之前，我对自己还是很有自信的，毕竟学了半年，怎么着小公司的offer还是可以拿到手的，拿到小公司offer在开始投大公司，开启offer收割机模式。然而我的脸被现实狠狠的打肿了。我面试了鲸灵、大华、兑吧、涂鸦！现实告诉我：你就是个彩笔！还他么想拿大厂的offer？做梦去吧！</p><p>事实上，我在面试的时候基本上都能够回答的出来面试官的问题，尤其是多线程和一些分布式相关的问题，Java基础、JVM更是一直在我的复习范围。然而，当面试官问到一些实际项目遇到的问题以及自己是如何解决的，我就歇菜了。例如实际生产中是如何做性能调优的，实际项目中遇到了哪些问题，是如何解决的？我知道面试官是想考察我解决问题的思路，然而当我将自己工作中所做的全盘托出，换来的却是面试官的鄙视！因为实在是太没有技术含量了，而我自己也确实没有在实际生产中遇到一些比较棘手的问题。这一周的面试将我的信心打压到谷底。</p><h4 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h4><p>幸运的是，我在正式办好离职手续的最后一个礼拜，一个大学的时候进了西安一个比较好的外企的同学告诉我，他们公司招人，问我要不要试一下。在从同花顺离职的时候，也就是一年之前，我有尝试面试过这家公司，可惜在homework阶段由于代码没有写的很好被淘汰了。这次，我要求自己要做好充足的准备。</p><p>他们公司面试不像杭州这边的互联网公司，面试总爱问一些高并发、分布式等等只会出现在面试中而不会出现在实际工作中的问题（当然这种说法也很片面）。这个外企的面试流程是给出一道程序设计题，3天时间提交代码，审核代码的质量以及是否优雅的完成题目要求，然后二面针对所做的题目增加需求，考察应试者实际动手能力以及程序设计能力。三面针对项目经验、工作经验再进行一轮面试。</p><p>9月6日周五下午4:19，我收到了这家公司的offer，丰厚的报酬和福利，还有离家近的条件让我无法拒绝这样一个offer。再加上在杭州这边面试的不顺利，我决定回去了。在我最后一个面试——杭州涂鸦的时候，我清楚地记得涂鸦HR很明确的告诉我，公司加班严重，大小周。我想，这样的公司是我想要去为之奋斗的吗？不，对于公司来说，员工都只是公司的一颗颗的螺丝钉，都是可被替代的零件，为何要为这种血汗工厂去牺牲自己的生活，杭州的996相必在最近五年之内都会是这个城市程序员的梦魇，最让人无奈的是，有些人竟然真的认为自己是在为自己“奋斗”，殊不知他们是被压迫的社会底层的劳动者，忘记了曾经的“8小时工作制”是由一些多么向往自由的人反抗争取来的，真正宣传996“福报”的资本家已经赚足了钱退休了（写于2019年9月10日）。</p><h4 id="回首"><a href="#回首" class="headerlink" title="回首"></a>回首</h4><p>我在写这篇博客的时候，脑中不断地回忆起17年2月底来到杭州直到现在发生的种种事情。确实由那句话所说，很多年后回想起来，你什么时候准备考研、出国留学、工作、恋爱、结婚生子、跳槽，都有可能会是人生中的一个大的转折点，而自己当时还只是认为这些事只是人生中很小的一件事情。</p><p>从同花顺跳槽去杭州的第二家公司工作，是我这两年最后悔的事情。如果我当时不从同花顺走，或者说在同花顺能有一些好的工作体验，也许目前就是另一种状态了吧。原本我跳槽后的计划是，在新的公司将自己沉淀两三年，将技术提升上去，三年后跳槽去一线大公司，但是无奈公司连支持我待够两年都做不到。2019年，其实是我最抑郁，世界最黑暗的一年。这年来，在新的公司工作，公司发展不顺利，志同道合的朋友也渐少，以前几个老朋友从每周几次在一起吃饭、玩的状态突然就变成一个月都见不了一面。也许是他们也都有了自己的女朋友，有了自己的生活，顾不上我了吧。而我每周末都想出去玩，却找不到同行的伙伴。</p><p>在杭州的两年时间，我去了周边的很多地方，刚毕业那会也许想的是，我终于获得了自己想要的自由生活，工资也足以让我到处去旅游。我曾经想，自己家要是江浙沪这一带的该有多好，西安那边真的很落后，虽然城市中不太看得出差距，但是城市周边的市、县、村，却是西北那边怎么也追赶不上来的。而且我在这边能够接触到更新的东西，一些新兴的互联网产品都会在这一带优先投放，例如共享单车、共享充电宝、智慧城市服务等等。我想杭州应该会是最优先开始智能化、互联网化的城市之一吧。</p><p>可惜了，即将离开这里，放弃两年来在这边拥有的一切。我的朋友，还有我的生活。虽然很不想说再见，但是谁又能主导自己的命运呢。</p><p>杭州，有缘再见吧！</p><p><img src="/blog/20190909/其实我不想离开这里/mu.jpg" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190909/其实我不想离开这里/fm.png&quot; alt=&quot;杭州西湖&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="程序人生" scheme="http://zhangjiaheng.cn/categories/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/"/>
    
    
      <category term="个人随笔" scheme="http://zhangjiaheng.cn/tags/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>如何在Spring Cloud项目中优雅的使用Rocket MQ</title>
    <link href="http://zhangjiaheng.cn/blog/20190819/%E5%A6%82%E4%BD%95%E5%9C%A8Spring%20Cloud%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8Rocket%20MQ/"/>
    <id>http://zhangjiaheng.cn/blog/20190819/如何在Spring Cloud中优雅的使用Rocket MQ/</id>
    <published>2019-08-19T02:32:44.000Z</published>
    <updated>2019-11-24T07:37:15.038Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190819/如何在Spring Cloud中优雅的使用Rocket MQ/fm.png" alt><br><a id="more"></a></p><blockquote><p>  很多时候，在一个项目诞生的初期，所有的业务都存在同一个服务中。业务之间的交互调用在同一个服务之间就可以快速高效完成，也没有什么高并发、业务解耦的需求要处理。当服务越来越庞大，我们一般会将服务进行垂直拆分，根据不同的功能模块，拆分成多个微服务。然而很多微服务之间的调用有的时候无需数据强一致性或者需要调用另一服务时不要求实时产生结果，完全可以通过异步的方式或者消息队列发送调用请求到下游服务，调用方完成自己的业务之后直接返回。RocketMQ在我们的项目中就扮演这样的角色——业务解耦（除了业务解耦，MQ还可以用来进行流量削峰填谷等功能）。</p></blockquote><h4 id="Rocket-MQ介绍"><a href="#Rocket-MQ介绍" class="headerlink" title="Rocket MQ介绍"></a>Rocket MQ介绍</h4><p>Rocket MQ 是阿里巴巴消息中间件团队开发的一款消息队列服务。其他的类似服务还有 RabbitMQ、ActiveMQ、Kafka等等。阿里原先使用的是MQ 系统可以用来完成异步任务处理、流量削峰填谷、服务之间解耦等功能。</p><p>在 RocketMQ 中有两个角色：nameserver、broker 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190819/如何在Spring Cloud中优雅的使用Rocket MQ/fm.png&quot; alt&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="消息队列" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="微服务" scheme="http://zhangjiaheng.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="springboot" scheme="http://zhangjiaheng.cn/tags/springboot/"/>
    
      <category term="spring cloud" scheme="http://zhangjiaheng.cn/tags/spring-cloud/"/>
    
      <category term="Rocket MQ" scheme="http://zhangjiaheng.cn/tags/Rocket-MQ/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(七)：Fork/Join框架原理及demo</title>
    <link href="http://zhangjiaheng.cn/blog/20190814/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%83-%EF%BC%9AFork-Join%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86%E5%8F%8Ademo/"/>
    <id>http://zhangjiaheng.cn/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/</id>
    <published>2019-08-14T08:48:56.000Z</published>
    <updated>2019-11-01T01:40:48.237Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/fm.jpg" alt="fm.jpg"></p><a id="more"></a><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Fork/Join框架是jdk1.7引入的一个基于“分治”思想的多线程框架。它的功能是将一个大任务切分(<strong>fork</strong>)成多个相同逻辑的小任务，分而治之，当子任务全都执行完成之后，将结果合并(<strong>join</strong>)起来，最终成为整体任务的执行结果。原理可以抽象成下图表示：</p><p><img src="/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/fj.png" alt="Fork/Join"></p><h3 id="Fork-Join相关代码原理及思想"><a href="#Fork-Join相关代码原理及思想" class="headerlink" title="Fork/Join相关代码原理及思想"></a>Fork/Join相关代码原理及思想</h3><h6 id="Fork-Join执行步骤"><a href="#Fork-Join执行步骤" class="headerlink" title="Fork/Join执行步骤"></a>Fork/Join执行步骤</h6><ol><li><p>进行任务分割：将任务分割成小任务，然后这个小任务有可能还需要继续分割，直到足够小。</p></li><li><p>执行并合并结果：分割的子任务分别放在双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，启动一个线程从队列里拿数据，然后合并这些数据。</p></li></ol><p>Fork/Join使用两个类完成以上步骤：</p><ul><li><strong>ForkJoinTask</strong>：<ul><li>Fork/Join提供了两个子类：RecursiveAction：用于没有返回结果的任务；RecursiveTask ：用于有返回结果的任务</li></ul></li><li><strong>ForkJoinPool</strong> ：<code>public class ForkJoinPool extends AbstractExecutorService{ ... }</code>ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。这种算法成为<strong>工作窃取算法(work-stealing)</strong></li></ul><h6 id="工作窃取算法-work-stealing"><a href="#工作窃取算法-work-stealing" class="headerlink" title="工作窃取算法(work-stealing)"></a>工作窃取算法(work-stealing)</h6><ul><li><p>Fork/Join框架内部实现了一个类似于LinkedBlockingDeque的双端队列用作工作线程的任务队列<strong>WorkQueue</strong>。使用<code>ForkJoinWorkerThread</code>保存工作线程，<code>ForkJoinPool.WorkQueue</code>就在其内部。</p></li><li><p>Fork/Join每个工作线程在运行中产生了新的任务(通常是调用fork方法)的时候，将任务加入WorkQueue尾部，并且工作线程每次取出任务执行也是从队尾取出执行，即LIFO</p></li><li><p>每个工作线程在处理自己的工作队列同时，会尝试窃取一个任务（或是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的工作队列），窃取的任务位于其他线程的工作队列的队首，也就是说工作线程在窃取其他工作线程的任务时，使用的是 FIFO 方式。</p></li><li><p>在遇到 join() 时，如果需要 join 的任务尚未完成，则会先处理其他任务，并等待其完成。</p></li><li><p>在既没有自己的任务，也没有可以窃取的任务时，进入休眠。</p></li></ul><h3 id="Fork-Join-demo演示"><a href="#Fork-Join-demo演示" class="headerlink" title="Fork/Join demo演示"></a>Fork/Join demo演示</h3><blockquote><p>使用Fork/Join完成大量有序数字的加和</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCalculateTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADSHOLD = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> end;</span><br><span class="line">  <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyCalculateTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.start = start;</span><br><span class="line">    <span class="keyword">this</span>.end = end;</span><br><span class="line">    <span class="keyword">this</span>.list = list;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (end - start &lt; THREADSHOLD) &#123;</span><br><span class="line">      <span class="comment">// 当两数字之间差值小于指定值 就不再查分成小任务 </span></span><br><span class="line">      String so = <span class="string">""</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">        sum += i;</span><br><span class="line">        so += list.get(i) + <span class="string">","</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"处理 "</span> + so + <span class="string">" 的数据"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">      <span class="comment">// 一分为二 拆分任务</span></span><br><span class="line">      <span class="keyword">final</span> MyCalculateTask left = <span class="keyword">new</span> MyCalculateTask(start, mid, list);</span><br><span class="line">      <span class="keyword">final</span> MyCalculateTask right = <span class="keyword">new</span> MyCalculateTask(mid, end, list);</span><br><span class="line">      left.fork();</span><br><span class="line">      right.fork();</span><br><span class="line">      sum += left.join();</span><br><span class="line">      sum += right.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">400</span>;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">      list.add(<span class="string">"i-"</span> + i);</span><br><span class="line">      sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">    MyCalculateTask task = <span class="keyword">new</span> MyCalculateTask(<span class="number">0</span>, count, list);</span><br><span class="line">    <span class="keyword">final</span> ForkJoinTask&lt;Integer&gt; submit = pool.submit(task);</span><br><span class="line">    System.out.println(<span class="string">"sum = "</span> + sum + <span class="string">" --- submit.get() = "</span> + submit.get());</span><br><span class="line">    pool.awaitTermination(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">    pool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Fork/Join框架可以帮助我们完成很多这种大任务可以拆分成小任务执行的场景，不过上面的方法并不是最佳执行调用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left.fork();  </span><br><span class="line">right.fork();</span><br><span class="line">替换为</span><br><span class="line">invokeAll(left, right);</span><br></pre></td></tr></table></figure><p>因为对于Fork/Join模式，假如Pool里面线程数量是固定的，那么调用子任务的fork方法相当于A先分工给B，然后A当监工不干活，B去完成A交代的任务。所以上面的模式相当于浪费了一个线程。那么如果使用invokeAll相当于A分工给B后，A和B都去完成工作。这样可以更好的利用线程池，缩短执行的时间。</p><blockquote><p>参考：<a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener">http://ifeve.com/talk-concurrency-forkjoin/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190814/并发编程学习-七-：Fork-Join框架原理及demo/fm.jpg&quot; alt=&quot;fm.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Fork/Join框架" scheme="http://zhangjiaheng.cn/tags/Fork-Join%E6%A1%86%E6%9E%B6/"/>
    
      <category term="ForkJoinPool" scheme="http://zhangjiaheng.cn/tags/ForkJoinPool/"/>
    
      <category term="线程池" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】设计模式基本思想以及23种模式总结整理</title>
    <link href="http://zhangjiaheng.cn/blog/20190812/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E4%BB%A5%E5%8F%8A23%E7%A7%8D%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/</id>
    <published>2019-08-12T03:47:54.000Z</published>
    <updated>2019-11-01T01:40:48.200Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/bz.png" alt="封面"></p><a id="more"></a><h3 id="设计模式主要思想"><a href="#设计模式主要思想" class="headerlink" title="设计模式主要思想"></a>设计模式主要思想</h3><p>设计模式是在长期应用开发过程中，众多开发者总结归纳出来的程序架构与设计思想。是经过实践证明的，可在实际背景下使用的一系列程序设计方案。设计模式产生的根本目的就是为了解决开发过程中重复的代码编写，以及让程序更易扩展复用。</p><h4 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h4><ul><li>单一职责：每个类都应该实现单一的功能，否则应该将类进行拆分</li><li>里氏替换：即继承复用/合成复用。尽量使用合成/聚合的方式而不是继承。任何父类出现的地方，子类都可以出现。派生类可以在基类的基础上扩展自己的功能实现。是对“开闭原则”的一个补充。在里氏替换原则中，尽量不要对父类进行重载或者重写，因为父类代表一个定义好的结构，通过规范好的接口与外界进行交互，子类不应该随意破坏它，而是对其进行扩展。</li><li>依赖倒置：“开闭原则”的基础。即面向接口编程。依赖于抽象而不是依赖于具体的实现，编程时遇到具体的类时，不与具体的类交互，而与抽象接口进行交互。便于增加新的具体类的时候代码可以复用。</li><li>接口隔离：每个接口不应该存在子类用不到却必须实现的方法，否则就应该将接口拆分，将职责单一化。</li><li>最少知道：即迪米特法则。一个类对于自己依赖的类知道的越少越好，无论被依赖的类多么复杂，都应该将逻辑封装在方法内部，通过一个共有的方法提供给依赖类使用，这样当被依赖类发生改变的时候，才会尽可能少的影响依赖类。</li></ul><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><blockquote><p>点击对应链接跳转到该设计模式的详细整理与代码示例</p></blockquote><table><thead><tr><th>范围</th><th>创建型模式</th><th>结构型模式</th><th>行为型模式</th></tr></thead><tbody><tr><td>对象创建</td><td><a href="http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/">Singleton（单例模式）</a><br>Prototype(原型模式)<br>Factory Method（工厂方法模式）<br>Abstract Factory（抽象工厂模式）<br>Builder（建造者模式）</td><td></td><td></td></tr><tr><td>接口适配</td><td></td><td>Adapter（适配器模式）<br>Bridge（桥接模式）<br>Facade（外观模式）</td><td></td></tr><tr><td>对象解耦</td><td></td><td></td><td>Mediator（中介者模式）<br>Observer（观察者模式）</td></tr><tr><td>抽象集合</td><td></td><td>Composite（组合模式）</td><td>Iterator（迭代器模式）</td></tr><tr><td>行为扩展</td><td></td><td>Decorator（装饰模式）</td><td>Visitor（访问者模式）<br>Chain of Responsibility（职责链）</td></tr><tr><td>算法封装</td><td></td><td></td><td><a href="http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">Template（模板方法模式）</a><br>Strategy（策略模式）</td></tr><tr><td>性能与对象访问</td><td></td><td>Flyweight（享元模式）<br>Proxy（代理模式）</td><td></td></tr><tr><td>对象状态</td><td></td><td></td><td>Memento（备忘录模式）<br>State（状态模式）</td></tr><tr><td>其他</td><td></td><td></td><td>Interpreter（解释器模式）</td></tr></tbody></table><h4 id="总结下设计模式的归类"><a href="#总结下设计模式的归类" class="headerlink" title="总结下设计模式的归类"></a>总结下设计模式的归类</h4><p><img src="/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/sjmo.png" alt="设计模式分类 - 幕布"></p><h4 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h4><p>创建型设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，使调用者无需new对象，在程序中针对给定业务场景去调用特定的对象创建方法，使程序更加灵活。</p><h4 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h4><p>行为型设计模式主要关注对象之间的通信。</p><h4 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h4><p>结构型设计模式关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190812/【设计模式】设计模式基本思想以及23种模式总结整理/bz.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式基本思想" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode - 52. N皇后 II 回溯算法求解</title>
    <link href="http://zhangjiaheng.cn/blog/20190809/Leetcode-52-N%E7%9A%87%E5%90%8E-II-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3/"/>
    <id>http://zhangjiaheng.cn/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/</id>
    <published>2019-08-09T10:19:50.000Z</published>
    <updated>2019-11-01T01:40:48.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="N皇后问题-leetcode"><a href="#N皇后问题-leetcode" class="headerlink" title="N皇后问题 - leetcode"></a>N皇后问题 - <a href="https://leetcode-cn.com/problems/n-queens-ii/" target="_blank" rel="noopener">leetcode</a></h4><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。<img src="/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/8-queens.png" alt="8皇后示例"><br>上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><blockquote><p>输入: 4<br>输出: 2<br>解释: 4 皇后问题存在如下两个不同的解法。<br><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">[".Q..",  // 解法 1</span><br><span class="line">"...Q",</span><br><span class="line">"Q...",</span><br><span class="line">"..Q."],</span><br><span class="line">["..Q.",  // 解法 2</span><br><span class="line">"Q...",</span><br><span class="line">"...Q",</span><br><span class="line">".Q.."]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p></blockquote><a id="more"></a><h4 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h4><p>使用回溯算法，深度优先搜索，进行遍历查询深度优先搜索的条件是有能够判断棋盘是否能落子的依据。</p><p>我这边使用一个长度为N的数组存储第J列是否有棋子，使用两个N*2-1长度的数组分别存储左对角线和右对角线是否有棋子。</p><p>对于左右对角线来说，左对角线的每一个位置i与j的和都相同，右对角线的每一个位置的i与j的差都相同，所以可以用来判断某个位置的斜线上是否存在棋子，对应对角线的数组标志为有或者没有。</p><h4 id="代码如下"><a href="#代码如下" class="headerlink" title="代码如下"></a>代码如下</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** 总记录数 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/** N皇后 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> N;</span><br><span class="line">  <span class="comment">/** 判断当前位置的左对角线是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">  <span class="comment">/** 判断当前位置的右对角线是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">15</span>];</span><br><span class="line">  <span class="comment">/** 判断当前位置的列是否存放了棋子 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span>[] curn;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.N = n;</span><br><span class="line">    curn = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    left = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    right = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span> * n - <span class="number">1</span>];</span><br><span class="line">    calResult(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">calResult</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 棋盘第i行 遍历判断第j列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++) &#123;</span><br><span class="line">      <span class="comment">// 开始判断第i行第j列</span></span><br><span class="line">      <span class="comment">// 判断第j列是否已经有棋子；判断(i,j)的左对角线是否有棋子；判断右对角线是否有棋子</span></span><br><span class="line">      <span class="keyword">if</span> (curn[j] == <span class="number">0</span> &amp;&amp; left[i + j] == <span class="number">0</span> &amp;&amp; right[N - <span class="number">1</span> + i - j] == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没有棋子 就可以在(i,j)放置棋子</span></span><br><span class="line">        curn[j] = left[i + j] = right[N - <span class="number">1</span> + i - j] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果N行都放置了棋子 total就加1 否则继续放置下一行</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; N - <span class="number">1</span>) &#123;</span><br><span class="line">          calResult(i + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          total++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放置完成之后 (i,j)位置棋子去掉，然后重新走下一步 进行深度优先搜索</span></span><br><span class="line">        curn[j] = left[i + j] = right[N - <span class="number">1</span> + i - j] = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">    solution.totalNQueens(<span class="number">8</span>);</span><br><span class="line">    System.out.println(<span class="string">"total = "</span> + solution.total);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;N皇后问题-leetcode&quot;&gt;&lt;a href=&quot;#N皇后问题-leetcode&quot; class=&quot;headerlink&quot; title=&quot;N皇后问题 - leetcode&quot;&gt;&lt;/a&gt;N皇后问题 - &lt;a href=&quot;https://leetcode-cn.com/problems/n-queens-ii/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。&lt;img src=&quot;/blog/20190809/Leetcode-52-N皇后-II-回溯算法求解/8-queens.png&quot; alt=&quot;8皇后示例&quot;&gt;&lt;br&gt;上图为 8 皇后问题的一种解法。给定一个整数 n，返回 n 皇后不同的解决方案的数量。&lt;/p&gt;
&lt;h4 id=&quot;示例：&quot;&gt;&lt;a href=&quot;#示例：&quot; class=&quot;headerlink&quot; title=&quot;示例：&quot;&gt;&lt;/a&gt;示例：&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;输入: 4&lt;br&gt;输出: 2&lt;br&gt;解释: 4 皇后问题存在如下两个不同的解法。&lt;br&gt;&lt;figure class=&quot;highlight md&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&quot;.Q..&quot;,  // 解法 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;...Q&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;Q...&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;..Q.&quot;],&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&quot;..Q.&quot;,  // 解法 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;Q...&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;...Q&quot;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&quot;.Q..&quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>我项目中使用的分布式事务：LCN</title>
    <link href="http://zhangjiaheng.cn/blog/20190806/%E6%88%91%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9ALCN/"/>
    <id>http://zhangjiaheng.cn/blog/20190806/我项目中使用的分布式事务：LCN/</id>
    <published>2019-08-06T03:14:44.000Z</published>
    <updated>2019-11-01T01:40:48.249Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190806/我项目中使用的分布式事务：LCN/tx.png" alt="官网首页"></p><center><a href="#more2">其他关于分布式事务的总结整理</a></center><a id="more"></a><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>由于公司项目是使用dubbo进行开发的分布式服务，所以项目中有很多涉及到分布式事务问题的场景。比如有两个模块：用户模块和账户资金模块。有一个场景是用户被邀请成为系统的新用户，需要先初始化用户信息，然后再去账户资金模块初始化用户账户信息。两个不同的模块为两个不同的RPC服务，分别被调用然后插入数据，这时候如果账户资金插入失败，不加入分布式事务的话用户直接初始化成功。我们希望这种情况下用户插入的信息被回滚，所以需要引入分布式事务来进行业务处理。</p><h4 id="使用的框架"><a href="#使用的框架" class="headerlink" title="使用的框架"></a>使用的框架</h4><p>经过调研，我们发现TX-LCN框架比较适合我们的业务场景，我们打算引入并使用LCN事务模式来进行服务中的分布式事务的业务处理。关于LCN、TCC、TXC几种事务模式的区别在<a href="#more2">下面</a>整理。</p><p>在<a href="https://www.txlcn.org/zh-cn/index.html" target="_blank" rel="noopener">官网</a>下载对应的服务，并引入项目或者单独启动：</p><p><img src="/blog/20190806/我项目中使用的分布式事务：LCN/tx.png" alt="官网首页"></p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transaction-dubbo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lcn.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.codingapi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tx-plugins-db<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;lcn.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><p>在服务的发起方使用注解<code>@TxTransaction(isStart = true)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@TxTransaction</span>(isStart = <span class="keyword">true</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ExperienceLogVO <span class="title">doUseExperience</span><span class="params">(Long userId, Long experienceRecordId, ExperienceLogCreateModel createModel)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">    userFacade.insert();</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">    accountFacede.insert();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务的参与方使用注解<code>@TxTransaction</code>标识即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TxTransaction</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="comment">// ... do something  ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再启动项目之前，先启动tx-manager服务，作为协调者的角色存在，然后启动项目，调用接口的时候就可以使用分布式事务了。</p><p><a id="more2" class="active"></a></p><h4 id="其他关于分布式事务的总结整理"><a href="#其他关于分布式事务的总结整理" class="headerlink" title="其他关于分布式事务的总结整理"></a>其他关于分布式事务的总结整理</h4><h5 id="关于Tx-LCN-官网文档"><a href="#关于Tx-LCN-官网文档" class="headerlink" title="关于Tx-LCN - 官网文档"></a>关于Tx-LCN - <a href="https://www.txlcn.org/zh-cn/docs/preface.html" target="_blank" rel="noopener">官网文档</a></h5><p>Tx-LCN早期是为了设计出LCN分布式事务而命名的，不过在5.0之后可以支持LCN、TXC、TCC三种分布式事务模式。LCN框架定位为<code>不生产事务，只做事务的搬运工</code>。即TX-LCN是一款事务协调框架，本身并不操作事务，只是基于对事务的协调从而达到事务一致性的效果。</p><p>最新版本的TX-LCN同时支持多种事务模式。并支持多种不同的数据源同时使用分布式事务，完全达到拔插效果。以下是三种事务模式的介绍、区别及优缺点。</p><h6 id="LCN事务模式"><a href="#LCN事务模式" class="headerlink" title="LCN事务模式"></a>LCN事务模式</h6><ul><li>仅仅作为事务的协调者，本身不生产事务。原理是在事务发起方创建事务分组，并通过Http/Tcp协议调用的时候将事务分组传递到事务参与方。事务参与方的本地事务执行成功之后，根据事务分组ID通知事务的发起方提交所有事务。在全部事务成功通知之前，其各个本地事务均为假关闭，等待TxManager协调完成事务之后再关闭连接。</li><li>LCN事务对于代码几乎没有嵌入性，只需要添加注解即可实现分布式事务。</li><li>LCN的事务提交与回滚都有本地事务保障，更安全的确保数据一致性。</li><li>但是LCN仅限于存在本地事务并且可以通过连接对象控制事务模块的系统。</li><li>LCN模式依赖于连接代理服务，事务的发起方与参与方要一起连接与释放，较耗性能。</li><li><img src="/blog/20190806/我项目中使用的分布式事务：LCN/LCN1.png" alt="情况1"></li><li><img src="/blog/20190806/我项目中使用的分布式事务：LCN/LCN2.png" alt="情况1"></li><li><img src="/blog/20190806/我项目中使用的分布式事务：LCN/LCN3.png" alt="情况1"><h6 id="TCC事务模式"><a href="#TCC事务模式" class="headerlink" title="TCC事务模式"></a>TCC事务模式</h6></li><li>TCC事务模式不依赖于资源管理器对于XA的支持，而是通过业务系统提供的业务逻辑的调度来实现分布式事务。即编写三步操作：Try：尝试执行业务（先插入一条数据，状态为Try）、Confrim：确认执行业务（成功后状态改为Confrim）、Cancel：取消执行业务（需要回滚的话根据前两个步骤的id继续更改状态或者删除数据）。</li><li>TCC模式对于代码的侵入性很高，基本上一个接口需要拆分成3个，对于程序员的编码要求很高，业务的正确性、数据一致性都由开发者来保证</li><li>优点是TCC模式对于有无本地事务的场景都适用，甚至可以跨数据源，针对MySQL、redis、Mongo等整合成一个大的事务<h6 id="TXC事务模式"><a href="#TXC事务模式" class="headerlink" title="TXC事务模式"></a>TXC事务模式</h6></li><li>其来源于阿里巴巴的一个分布式事务中间件，可以通过极少量的代码侵入，实现分布式事务。原理是在执行SQL之前，先查询SQL的影响数据，然后保存执行的SQL快照信息并创建锁。当需要回滚的时候就采用这些记录回滚数据库。目前实现锁使用的是redis分布式锁控制。</li><li>TXC事务模式同样对代码的侵入性低</li><li>该模式仅限于对支持SQL方式的模块支持</li><li>该模式由于每次执行SQL之前需要先查询影响数据，因此相比LCN模式更消耗性能</li><li>TXC事务模式不会占用数据库资源</li><li>关于TXC事务的详细介绍可以查看<a href="https://blog.csdn.net/m0_38110132/article/details/77043580" target="_blank" rel="noopener">这篇博客</a></li></ul><h5 id="CAP理论和BASE理论"><a href="#CAP理论和BASE理论" class="headerlink" title="CAP理论和BASE理论"></a>CAP理论和BASE理论</h5><h6 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h6><p>CAP理论即数据一致性、服务可用性和分区容错性的简称。</p><ul><li>Consistency 数据一致性：一次完整的更新操作，所有节点在同一时刻访问到的数据是一致的</li><li>Availability 服务可用性：服务一直可用，并且是正常响应时间</li><li>Partition tolerance 分区容错性：分布式多节点在某几个节点挂掉后仍然可以对外提供正常的服务</li></ul><p>事实上，CAP这三种并无法保证完全满足，一般只能满足其二。对于分布式系统来说，分区容错性是最基本需要满足的条件，否则不能称为分布式系统，只满足CA 其实是传统的单机服务。那么在满足P（分区容错）的时候，就需要在C和A之间权衡。事实上，分布式系统下一般会保证A（服务可用）P，放弃数据的强一致性，只保证数据的最终一致性。这样就衍生出了BASE理论。</p><h6 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h6><p>BASE是Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）三个短语的缩写。BASE理论是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于CAP定理逐步演化而来的。BASE理论的核心思想是：<strong>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性</strong>。</p><ul><li>基本可用：在分布式系统中，允许在出现不可预知故障的情况下损失部分可用性（并不是允许系统不可用），允许响应时间上的确实和部分系统功能的错误（并发场景下拒绝服务产生报错等）</li><li>软状态：即允许数据存在中间状态，允许不同节点的数据之间存在时间上的数据差异</li><li>最终一致性：强调所有数据副本能够最终一致，不需要保证数据实时强一致。</li></ul><p>传统事务的ACID机制追求强一致性，而BASE理论为分布式系统而生，主张牺牲强一致性，使得服务达到高可用。不过在分布式系统中，不同场景下对于数据的一致性又是不同的，所以才会有分布式事务来保证数据的一致，即ACID与BASE理论结合使用。</p><h5 id="2PC和3PC"><a href="#2PC和3PC" class="headerlink" title="2PC和3PC"></a>2PC和3PC</h5><h6 id="2PC-二段式提交"><a href="#2PC-二段式提交" class="headerlink" title="2PC - 二段式提交"></a>2PC - 二段式提交</h6><p>2PC，是Two-Phase Commit的缩写。过程如下：</p><ul><li><p>阶段一：提交事务请求</p><ul><li>协调者询问参与方是否可以执行提交操作并等待响应</li><li>参与者执行询问为止的所有事务操作</li><li>参与者响应协调者，返回事务执行成功与否</li></ul></li><li><p>阶段二：执行事务提交</p><ul><li><p>协调者收到所有第一阶段响应之后发起正式提交请求</p></li><li><p>参与者正式完成操作并释放整个事务期间占用的资源</p></li><li><p>反馈事务提交结果</p></li><li><p>协调者收到所有完成的消息后，完成事务。</p></li><li><p>如果任意参与者在第一阶段返回执行失败或者超时的消息，中断事务</p></li><li><p>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</p></li><li><p>参与者节点向协调者节点发送”回滚完成”消息。</p></li><li><p>协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务。</p></li><li><p>不管最后结果如何，第二阶段都会结束当前事务</p></li></ul></li></ul><p>  <strong>2PC的缺点：</strong> 执行过程中所有节点都是同步阻塞的；如果协调者是单点并且发生故障，参与者将一直阻塞；如果在第二阶段协调者正式向所有参与者发送正式提交事务的请求，其中部分因为网络问题没有收到，另一部分却已经提交无法回滚，出现数据不一致的情况；协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p><p>  由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p><h6 id="3PC-三段式提交"><a href="#3PC-三段式提交" class="headerlink" title="3PC - 三段式提交"></a>3PC - 三段式提交</h6><p>3PC将2PC的准备阶段又划分为两次准备，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。。并且在协调者与参与者中都引入超时机制。</p><ul><li><p>CanCommit阶段</p><ul><li>同2PC的准备阶段，协调者向参与者发送事务提交请求，询问并等待响应</li><li>得到响应之后进入预备提交阶段</li></ul></li><li><p>PreCommit阶段</p><ul><li>所有参与者第一阶段都返回成功状态，那么就会开始事务的预执行</li><li>进入PreCommit并执行事务操作，全部成功就返回给提交者</li><li>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。发送中断请求协调者向所有参与者发送abort请求;中断事务参与者收到来自协调者的abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li></ul></li><li><p>doCommit阶段</p><ul><li><p>发送提交请求协调接收到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</p></li><li><p>事务提交参与者接收到doCommit请求之后，执行正式的事务提交。并在完成事务提交之后释放所有事务资源。</p></li><li><p>响应反馈事务提交完之后，向协调者发送Ack响应。</p></li><li><p>完成事务协调者接收到所有参与者的ack响应之后，完成事务。</p></li></ul></li></ul><p>  中断事务协调者没有接收到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p><ul><li><p>发送中断请求协调者向所有参与者发送abort请求</p></li><li><p>事务回滚参与者接收到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚之后释放所有的事务资源。</p></li><li><p>反馈结果参与者完成事务回滚之后，向协调者发送ACK消息</p></li><li><p>中断事务协调者接收到参与者反馈的ACK消息之后，执行事务的中断。</p></li></ul><p>  相比于2PC，3PC最关键要解决的就是协调者和参与者同时挂掉的问题，所以3PC把2PC的准备阶段再次一分为二。在第一阶段只是询问所有参与者是否都可以执行事务操作，并不在本阶段执行事务操作。当协调者收到所有的参与者都返回YES时，在第二阶段才执行事务操作，然后在第三阶段在执行commit或者rollback。</p><p>  <strong>3PC存在的问题：</strong> 在doCommit阶段，如果参与者无法及时接收到来自协调者的doCommit或者abort请求时，会在等待超时之后，会继续进行事务的提交。这样与其他执行回滚的参与者就会出现数据不一致的情况。</p><hr><blockquote><p>参考：</p><ul><li><p><a href="https://www.hollischuang.com/archives/1580" target="_blank" rel="noopener">https://www.hollischuang.com/archives/1580</a></p></li><li><p><a href="http://anruence.com/2018/03/05/tcc-2pc-3pc/" target="_blank" rel="noopener">http://anruence.com/2018/03/05/tcc-2pc-3pc/</a></p></li><li><p><a href="http://blog.jobbole.com/95632/" target="_blank" rel="noopener">http://blog.jobbole.com/95632/</a></p></li><li><a href="http://blog.csdn.net/zhangjq520/article/details/78433686" target="_blank" rel="noopener">http://blog.csdn.net/zhangjq520/article/details/78433686</a></li><li><a href="https://www.zhihu.com/question/48627764/answer/111983553" target="_blank" rel="noopener">https://www.zhihu.com/question/48627764/answer/111983553</a></li><li><a href="https://www.jianshu.com/p/d3eda795188a" target="_blank" rel="noopener">https://www.jianshu.com/p/d3eda795188a</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190806/我项目中使用的分布式事务：LCN/tx.png&quot; alt=&quot;官网首页&quot;&gt;&lt;/p&gt;
&lt;center&gt;&lt;a href=&quot;#more2&quot;&gt;其他关于分布式事务的总结整理&lt;/a&gt;&lt;/center&gt;
    
    </summary>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="分布式事务" scheme="http://zhangjiaheng.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="http://zhangjiaheng.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="分布式" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="数据库" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式事务" scheme="http://zhangjiaheng.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode上的几个多线程编程题解</title>
    <link href="http://zhangjiaheng.cn/blog/20190724/LeetCode%E4%B8%8A%E7%9A%84%E5%87%A0%E4%B8%AA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E9%A2%98%E8%A7%A3/"/>
    <id>http://zhangjiaheng.cn/blog/20190724/LeetCode上的几个多线程编程题解/</id>
    <published>2019-07-24T07:16:20.000Z</published>
    <updated>2019-11-01T01:40:48.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190724/LeetCode上的几个多线程编程题解/fm.png" alt></p><a id="more"></a><h3 id="以下所有题目的题解-github"><a href="#以下所有题目的题解-github" class="headerlink" title="以下所有题目的题解 - github"></a><a href="https://github.com/Fatezhang/DataStructureAndAlgorithm/tree/master/src/main/java/Alogrithm/Alogrithm" target="_blank" rel="noopener">以下所有题目的题解 - github</a></h3><h4 id="1、按序打印"><a href="#1、按序打印" class="headerlink" title="1、按序打印"></a>1、<a href="https://leetcode-cn.com/problems/print-in-order" target="_blank" rel="noopener">按序打印</a></h4><ul><li>方法一：使用volatile变量控制顺序</li><li>思路：利用volatile语义，实现变量的内存可见性，使得别的线程在修改完state状态变量的时候结果对于另一个线程立即可见。这样每个线程在打印的时候就可以通过状态判断是不是该轮到自己执行了。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        state = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond.run();</span><br><span class="line">        state = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (state != <span class="number">3</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird.run();</span><br><span class="line">        state = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：使用CountDownLatch控制顺序（只适用于执行一次。。。可以使用循环栅栏改一下~）</li><li>CountDownLatch俗称“闭锁”。使用闭锁来控制线程是否该执行，在没有达到条件时，闭锁阻塞线程。这样在第一个线程执行完成之后打开第二个线程的闭锁，第二个执行完成之后打开第三个线程的闭锁，实现按照顺序打印。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch2 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch3 = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">first</span><span class="params">(Runnable printFirst)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        <span class="comment">// printFirst.run() outputs "first". Do not change or remove this line.</span></span><br><span class="line">        printFirst.run();</span><br><span class="line">        countDownLatch2.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">second</span><span class="params">(Runnable printSecond)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        countDownLatch2.await();</span><br><span class="line">        <span class="comment">// printSecond.run() outputs "second". Do not change or remove this line.</span></span><br><span class="line">        printSecond.run();</span><br><span class="line">        countDownLatch3.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">third</span><span class="params">(Runnable printThird)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        countDownLatch3.await();</span><br><span class="line">        <span class="comment">// printThird.run() outputs "third". Do not change or remove this line.</span></span><br><span class="line">        printThird.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="2、交替打印FooBar"><a href="#2、交替打印FooBar" class="headerlink" title="2、交替打印FooBar"></a>2、<a href="https://leetcode-cn.com/problems/print-foobar-alternately" target="_blank" rel="noopener">交替打印FooBar</a></h4><ul><li>思路：使用显示可重入锁加上Condition条件阻塞机制，再加上volatile修饰的状态变量控制打印顺序。线程打印时加锁，如果状态是使当前线程打印，就打印并且转换状态，然后唤醒另一个线程。下一次再判断当前状态不适合打印，就使用第一个条件锁阻塞当前线程。以此类推。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 交替打印FooBar */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FooBar</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">FooBar</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(Runnable printFoo)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                c1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printFoo.run() outputs "foo". Do not change or remove this line.</span></span><br><span class="line">            printFoo.run();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            c2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(Runnable printBar)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">                c2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printBar.run() outputs "bar". Do not change or remove this line.</span></span><br><span class="line">            printBar.run();</span><br><span class="line">            flag = !flag;</span><br><span class="line">            c1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、打印0与奇偶数"><a href="#3、打印0与奇偶数" class="headerlink" title="3、打印0与奇偶数"></a>3、<a href="https://leetcode-cn.com/problems/print-zero-even-odd" target="_blank" rel="noopener">打印0与奇偶数</a></h4><ul><li>思路：也是使用显示可重入锁加上条件阻塞机制，加上volatile修饰的状态变量控制奇偶数的打印。不符合当前执行的状态就使用condition阻塞，符合就执行并且转换状态，然后唤醒其他线程。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"><span class="keyword">import</span> java.util.function.IntConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> https://leetcode-cn.com/problems/print-zero-even-odd</span></span><br><span class="line"><span class="comment"> * 3个线程交替打印奇偶数和0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZeroEvenOdd</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ZeroEvenOdd</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition c1 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c2 = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition c3 = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 0-打印0 1-打印奇数 2-打印偶数 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">zero</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">0</span>) &#123;</span><br><span class="line">          c1.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> ((i &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">          flag = <span class="number">1</span>;</span><br><span class="line">          c3.signal();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          flag = <span class="number">2</span>;</span><br><span class="line">          c2.signal();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">even</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">2</span>) &#123;</span><br><span class="line">          c2.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        c1.signal();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">odd</span><span class="params">(IntConsumer printNumber)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (flag != <span class="number">1</span>) &#123;</span><br><span class="line">          c3.await();</span><br><span class="line">        &#125;</span><br><span class="line">        printNumber.accept(i);</span><br><span class="line">        flag = <span class="number">0</span>;</span><br><span class="line">        c1.signal();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ZeroEvenOdd zeroEvenOdd = <span class="keyword">new</span> ZeroEvenOdd(<span class="number">5</span>);</span><br><span class="line">    ThreadPoolExecutor pools =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, TimeUnit.MINUTES, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), r -&gt; <span class="keyword">new</span> Thread(r, <span class="string">"某线程"</span>));</span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.zero(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.even(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    pools.execute(</span><br><span class="line">        () -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            zeroEvenOdd.odd(System.out::print);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、H2O生成"><a href="#4、H2O生成" class="headerlink" title="4、H2O生成"></a>4、<a href="https://leetcode-cn.com/problems/building-h2o" target="_blank" rel="noopener">H2O生成</a></h4><ul><li>方法一：使用显示锁和condition</li><li>思路：老生常谈的思路了，同上面一样的原理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.Condition;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 水分子生成 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2O</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">H2O</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Condition H = lock.newCondition();</span><br><span class="line">  <span class="keyword">private</span> Condition O = lock.newCondition();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> hCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">while</span> (hCount == <span class="number">2</span>) &#123;</span><br><span class="line">        H.await();</span><br><span class="line">      &#125;</span><br><span class="line">      hCount++;</span><br><span class="line">      releaseHydrogen.run();</span><br><span class="line">      <span class="keyword">if</span> (hCount == <span class="number">2</span>) &#123;</span><br><span class="line">        O.signal();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        H.signal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">while</span> (hCount != <span class="number">2</span>) &#123;</span><br><span class="line">        O.await();</span><br><span class="line">      &#125;</span><br><span class="line">      hCount = <span class="number">0</span>;</span><br><span class="line">      releaseOxygen.run();</span><br><span class="line">      H.signal();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"HHOOOHHHH"</span>;</span><br><span class="line">    <span class="keyword">final</span> H2O o = <span class="keyword">new</span> H2O();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'H'</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.hydrogen(() -&gt; System.out.print(<span class="string">"H"</span>));</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            .start();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.oxygen(() -&gt; System.out.print(<span class="string">"O"</span>));</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            .start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>方法二：使用信号量控制通知线程</li><li>思路：使用信号量控制线程间的通信。分别分为执行信号和唤醒信号，氢原子的执行信号首先为2，氧原子的执行信号首先为1。氢氧线程执行时消耗执行信号量，当一个氢原子执行后，氢原子的释放信号开始释放（只有一个氧线程等待其释放），然后等待氧原子释放信号释放（即一个氧原子已经产生），之后产生一个氢原子在释放请求信号。氧线程执行时，开始请求释放一个氧原子，成功之后氧线程释放信号开始释放（因为2个氢线程等待所以释放两个信号），然后等待氢线程释放两个信号（说明已经有两个氢原子生成）。然后再生成氧原子，成功之后在释放氧线程的请求信号。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@Author</span> zhangjiaheng <span class="doctag">@Description</span> 使用信号量控制水分子生成 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">H2O_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Semaphore hAcquire, oAcquire, hRelease, oRelease;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">H2O_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// H 原子线程 请求信号</span></span><br><span class="line">    hAcquire = <span class="keyword">new</span> Semaphore(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// O 原子线程 请求信号</span></span><br><span class="line">    oAcquire = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// H 原子线程 释放信号</span></span><br><span class="line">    hRelease = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// O 原子线程 释放信号</span></span><br><span class="line">    oRelease = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hydrogen</span><span class="params">(Runnable releaseHydrogen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    hAcquire.acquire(); <span class="comment">// H线程开始请求</span></span><br><span class="line">    hRelease.release(); <span class="comment">// 通知一个H线程即将释放 因为一个H线程释放最多只有一个O线程等待其释放</span></span><br><span class="line">    oRelease.acquire(); <span class="comment">// 等待O线程释放 一个O线程释放就可以通过</span></span><br><span class="line">    releaseHydrogen.run();</span><br><span class="line">    hAcquire.release(); <span class="comment">// 唤醒H线程请求</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">oxygen</span><span class="params">(Runnable releaseOxygen)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    oAcquire.acquire(); <span class="comment">// O线程开始请求</span></span><br><span class="line">    oRelease.release(<span class="number">2</span>); <span class="comment">// 通知一个O线程即将释放 因为一个O线程释放 会有两个H线程等待其释放</span></span><br><span class="line">    hRelease.acquire(<span class="number">2</span>); <span class="comment">// 等待H线程释放 要等待两次释放 才可以通过</span></span><br><span class="line">    releaseOxygen.run();</span><br><span class="line">    oAcquire.release(); <span class="comment">// 唤醒O线程请求</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHOOHHOOOOOHOOOHHHOHHHHOOOHHHOOOHOHOHOHHOHOOHHHOOHOOOHHOOOOHOHHHHOOOOOHHHOOOHOHOHOOOHHOHOOHHOHHHHHHHHHHHHHHHHHHHHHHHHHHH"</span>;</span><br><span class="line">    <span class="keyword">final</span> H2O_2 o = <span class="keyword">new</span> H2O_2();</span><br><span class="line">    ThreadPoolExecutor pool =</span><br><span class="line">        <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">300</span>,</span><br><span class="line">            <span class="number">10</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">100</span>),</span><br><span class="line">                (ThreadFactory) Thread::<span class="keyword">new</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c == <span class="string">'H'</span>) &#123;</span><br><span class="line">        pool.execute(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                o.hydrogen(() -&gt; System.out.print(<span class="string">"H"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pool.execute(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                o.oxygen(() -&gt; System.out.print(<span class="string">"O"</span>));</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190724/LeetCode上的几个多线程编程题解/fm.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="leetcode" scheme="http://zhangjiaheng.cn/tags/leetcode/"/>
    
      <category term="算法题解" scheme="http://zhangjiaheng.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E8%A7%A3/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized使用时一个不起眼的注意点</title>
    <link href="http://zhangjiaheng.cn/blog/20190716/Synchronized%E4%BD%BF%E7%94%A8%E6%97%B6%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%B5%B7%E7%9C%BC%E7%9A%84%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://zhangjiaheng.cn/blog/20190716/Synchronized使用时一个不起眼的注意点/</id>
    <published>2019-07-16T09:12:47.000Z</published>
    <updated>2019-11-01T01:40:48.191Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Synchronized-前情提要"><a href="#Synchronized-前情提要" class="headerlink" title="Synchronized 前情提要"></a>Synchronized 前情提要</h4><p>Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。</p><ul><li>修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。</li><li>修饰普通方法：锁的是当前实例对象，修饰方法时同上。</li><li>修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。</li></ul><p>Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。</p><a id="more"></a><h4 id="切入正题"><a href="#切入正题" class="headerlink" title="切入正题"></a>切入正题</h4><p>以上知识点想必刚开始学习并发编程的程序员都会先学习以上知识，但是很多程序员在使用Synchronized的时候有可能会发现，我明明加锁了，但是方法却并没有同步执行，这到底是什么原因？先看下如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码启动了20个线程，对Integer变量cn进行自增。很多人在写Synchronized的时候都有可能出现这种问题。这样的写法是错误的！</p><p>因为<code>cn++</code>这句代码的原理是将cn指向一个cn+1的新的Integer对象！</p><p>修改成如下，然后看看输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Integer cn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch cd = <span class="keyword">new</span> CountDownLatch(size);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">        <span class="keyword">int</span> finalJ = j;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">            () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cd.countDown();</span><br><span class="line">                    cd.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (cn) &#123;</span><br><span class="line">                        cn++;</span><br><span class="line">                        System.out.println(</span><br><span class="line">                            <span class="string">"cn"</span> + finalJ + <span class="string">" = "</span> + cn + <span class="string">"\t\t\t"</span> + System.identityHashCode(cn));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以上代码输出如下 &gt;&gt;</strong></p><p><img src="/blog/20190716/Synchronized使用时一个不起眼的注意点/cons.png" alt="输出"></p><p>每次输出的Integer对象的HashCode值并不相同。所以，每次锁的并不是同一个对象！既然不是同一个对象，那么这个方法在多线程访问的时候肯定就不是线程安全的！对于如上这种例子我们当然可以使用原子变量<code>AtomicInteger</code>来实现更高级的同步机制去解决这个问题，但是其他场景下呢？</p><p>不仅仅是Integer对象哦！所有的对象都有可能会有这些问题存在！当你在锁这个对象的时候，一定要保证加锁的对象在线程中不被修改成另一个对象！否则就是一个<strong>假的</strong>同步代码块！</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Synchronized-前情提要&quot;&gt;&lt;a href=&quot;#Synchronized-前情提要&quot; class=&quot;headerlink&quot; title=&quot;Synchronized 前情提要&quot;&gt;&lt;/a&gt;Synchronized 前情提要&lt;/h4&gt;&lt;p&gt;Synchronized是Java中用来进行方法或者代码同步的一个内置锁机制。这种内置锁机制可以保证代码执行的原子性、可见性，但是并不能屏蔽代码的重排序。Synchronized可以修饰方法、对象以及代码块，并可以保证被修饰的方法或者代码块，在同一个时刻只能有一个线程能够访问得到。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修饰静态方法：锁的是当前类的class对象，修饰方法时Synchronized没有表现在字节码指令中，而是在class文件的方法表中将该方法的access_flags值置为1。表示该方法是同步方法，并使用调用该方法的对象或该方法所属的 Class 在 JVM 的内部对象表示 Klass 作为锁对象。&lt;/li&gt;
&lt;li&gt;修饰普通方法：锁的是当前实例对象，修饰方法时同上。&lt;/li&gt;
&lt;li&gt;修饰代码块：锁的是Synchronized()中的对象，编译后的字节码会在代码块前后插入monitorenter 和monitorexit。JVM需要每一个monitorenter都有一个monitorexit与之对应，任何对象都有一个monitor与之相对应，当一个monitor被持有，即线程执行到monitorenter时，对象将处于锁定状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Synchronized是Java内置的重量级锁，在jdk1.6之后引入了自旋锁、轻量级锁、适应性自旋、锁粗化、锁消除、偏向锁等技术来减少Synchronized的性能开销。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Synchronized" scheme="http://zhangjiaheng.cn/tags/Synchronized/"/>
    
  </entry>
  
  <entry>
    <title>一个[合格]的程序员必须具备的工具和插件</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E4%B8%80%E4%B8%AA-%E5%90%88%E6%A0%BC-%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%91%98%E5%BF%85%E9%A1%BB%E5%85%B7%E5%A4%87%E7%9A%84%E5%B7%A5%E5%85%B7%E5%92%8C%E6%8F%92%E4%BB%B6/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/一个-合格-的程序员必须具备的工具和插件/</id>
    <published>2019-07-14T13:38:04.000Z</published>
    <updated>2019-11-01T01:40:48.205Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg" alt="封面"><br><a id="more"></a></p><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><strong>如题… 是我标题党了，应该这样讲：“合格的程序员”不一定需要会使用哪些工具，但是会使用那些能够有效减少自己工作量的很酷的工具和插件的程序员一定会进步成一个“合格的程序员”。因为他们善于思考，并能够将繁杂的重复性工作交给工具去完成，将精力集中在核心的编码任务上。</strong></p><h4 id="逐个介绍那些我自己常用的工具、插件或者网站"><a href="#逐个介绍那些我自己常用的工具、插件或者网站" class="headerlink" title="逐个介绍那些我自己常用的工具、插件或者网站"></a>逐个介绍那些我自己常用的工具、插件或者网站</h4><h5 id="Ghelper"><a href="#Ghelper" class="headerlink" title="Ghelper"></a><a href="http://googlehelper.net/" target="_blank" rel="noopener">Ghelper</a></h5><p>说到工具，不会翻墙用啥子工具。Ghelper是一个谷歌浏览器插件，直接下载安装到chrome扩展即可轻松访问谷歌等服务！注意，访问谷歌的相关服务是免费的哦！如果你有需求访问其他的例如YouTuBe、Twitter之类的，可以购买会员服务！这里还有一个谷歌访问助手破解版，我没有试过，有兴趣可以装一下看看：<a href="https://github.com/haotian-wang/google-access-helper" target="_blank" rel="noopener">GHelper破解版</a><br>这个工具可以说是以下大部分工具的基础。</p><h5 id="FeHelper"><a href="#FeHelper" class="headerlink" title="FeHelper"></a><a href="https://www.baidufe.com/fehelper/feedback.html" target="_blank" rel="noopener">FeHelper</a></h5><p>FeHelper是一个在谷歌浏览器上我最常用的一个插件。功能如下，字符串编解码、JSON格式化、时间戳转换等等工具，在做web开发的时候查看某个JSON数据格式是否正确直接黏贴到这个框里就OK，简单暴力~</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/feh.png" alt="FeHelper"></p><h5 id="油猴儿"><a href="#油猴儿" class="headerlink" title="油猴儿"></a><a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">油猴儿</a></h5><p>大名鼎鼎的油猴儿想必很多程序员都了解以及用过吧(没用过别告诉我你是个程序员，死敲代码的)。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/yh.png" alt="油猴儿"></p><p>如上图就是我的一些油猴儿插件的已安装的一部分脚本的截图。例如看各大视频网站，不想要买VIP去看，那么直接安装一个VIP视频破解脚本；或者百度网盘，拒绝启动客户端下载文件，安装个油猴脚本直接直链下载！</p><p>油猴儿在我看来就是一个浏览器脚本的容器，网上极客众多，你可以找得到任何自己感兴趣的想要安装的插件去完成自己要做的事情。</p><p>油猴儿的安装：<a href="https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo" target="_blank" rel="noopener">谷歌应用商店 - 油猴儿</a>，安装完成之后你就可以找到任何你想要的脚本装在油猴儿里面啦！</p><p>这边，我只告诉大家一个终极脚本：<a href="https://greasyfork.org/zh-CN/scripts/24508-userscript-show-site-all-userjs" target="_blank" rel="noopener">UserScript+</a>。为啥叫它终极脚本。。。因为安装上它之后，当你打开任何网站，他都会提示你这个网站可以安装的脚本有哪些，这样你就不用在茫茫大海中去寻找自己需要的那些脚本了。</p><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/jb.png" alt="掘金油猴儿脚本"></p><p>可以想象，有了这个之后，面向百度编程的程序员是不是不用再被眼花缭乱的广告所骚扰！喜欢使用掘金的程序员也可以设置自己喜欢的页面排版~ 经常水V2EX的程序员也可以在评论区盖楼了！！哈哈想想就刺激呢！</p><h5 id="云盘精灵"><a href="#云盘精灵" class="headerlink" title="云盘精灵"></a><a href="https://www.yunpanjingling.com/" target="_blank" rel="noopener">云盘精灵</a></h5><p><img src="/blog/20190714/一个-合格-的程序员必须具备的工具和插件/ypjl.png" alt="云盘精灵"></p><p>云盘精灵是一个下载百度网盘资源的神奇的网站，在这里你几乎可以找到任何您想要的资源去下载。然鹅，需要注册然后使用豆子购买。不过这也是理所应当的，毕竟知识付费的天下。但是需要付的并不多，而且你还可以将你自己的资源分享到云盘精灵，有人下载你也会赚取到相应的豆子。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/一个-合格-的程序员必须具备的工具和插件/gtx.jpg&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>将阿里Java编码规范敲成思维导图</title>
    <link href="http://zhangjiaheng.cn/blog/20190714/%E5%B0%86%E9%98%BF%E9%87%8CJava%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%95%B2%E6%88%90%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/"/>
    <id>http://zhangjiaheng.cn/blog/20190714/将阿里Java编码规范敲成思维导图/</id>
    <published>2019-07-14T03:12:01.000Z</published>
    <updated>2019-11-01T01:40:48.223Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png" alt="阿里Java编码规范"></p><p><center>阿里Java编码规范</center><br><a id="more"></a></p><p><center></center></p><p><center><a href="https://mubu.com/doc/CuUSIfxtSz" target="_blank" rel="noopener">可以点击这里查看分享的笔记</a></center></p><p><center></center></p><p><center></center></p><p><center>或者扫描如下二维码获取我分享的《阿里Java开发手册-幕布版》</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/qrcode.png" alt></p><p><center></center></p><p><center></center></p><h2 id><a href="#" class="headerlink" title></a><center></center></h2><p><center>最后，思维导图效果如下，密集恐惧症慎入~~</center></p><p><center>查看清晰完整的效果请去幕布笔记，点击查看思维导图即可</center><br><img src="/blog/20190714/将阿里Java编码规范敲成思维导图/阿里Java编码规范.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190714/将阿里Java编码规范敲成思维导图/fm.png&quot; alt=&quot;阿里Java编码规范&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;center&gt;阿里Java编码规范&lt;/center&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="开发工具" scheme="http://zhangjiaheng.cn/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>【设计模式】模板方法模式</title>
    <link href="http://zhangjiaheng.cn/blog/20190707/%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>http://zhangjiaheng.cn/blog/20190707/【设计模式】模板方法模式/</id>
    <published>2019-07-07T02:32:44.000Z</published>
    <updated>2019-11-01T01:40:48.196Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190707/【设计模式】模板方法模式/fm.png" alt="封面"><br><a id="more"></a></p><h4 id="什么是模板方法模式"><a href="#什么是模板方法模式" class="headerlink" title="什么是模板方法模式"></a>什么是模板方法模式</h4><p>在计算机程序中，为了将一些具有不同实现但有相同执行步骤的类统一起来，通常我们将这些类抽象成一个模板类。模板类定义了一个算法的框架，使得子类可以不改变算法的结构而去对一些细节实现进行重新定义。</p><h4 id="模板方法模式的核心要素"><a href="#模板方法模式的核心要素" class="headerlink" title="模板方法模式的核心要素"></a>模板方法模式的核心要素</h4><h5 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h5><p>抽象模板中定义了两种方法：需要子类去实现的基本方法，以及固定的不需要子类去实现的具体算法步骤的模板方法。基本方法在模板方法中被调用，模板方法一般会是一个具体的算法框架，调度基本方法完成所有功能。</p><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>子类具体实现抽象模板中的基本方法，完成对框架中的算法细节进行重新定义。</p><h4 id="我在实际项目中使用的案例"><a href="#我在实际项目中使用的案例" class="headerlink" title="我在实际项目中使用的案例"></a>我在实际项目中使用的案例</h4><p>在做某个按需查询不同类别的用户，并将其上传到OSS上，每日发邮件告诉运营人员结果的一个需求的时候，我就用到了模板方法模式。<br>首先定义一个抽象模板，分别有查询用户(每天都不同的SQL)，上传到OSS，发邮件等几个步骤，即基本方法。在模板方法中将这几个步骤封装起来。定义7个子类分别对每天不同的查询、上传、邮件做具体的实现。最后根据策略模式，不同的星期调用不同的对象的模板方法完成核心功能。</p><h4 id="模板方法模式代码示例"><a href="#模板方法模式代码示例" class="headerlink" title="模板方法模式代码示例"></a>模板方法模式代码示例</h4><p>如图，有个做饭的抽象模板：定义了[洗菜-炒菜-完成]三个步骤为基本方法，一个<code>ComplateCook</code>方法完成步骤的组装</p><p><img src="/blog/20190707/【设计模式】模板方法模式/bb.png" alt="抽象模板"></p><p>一个西红柿炒蛋的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z1.png" alt="子类1"></p><p>一个鱼香肉丝的实现类</p><p><img src="/blog/20190707/【设计模式】模板方法模式/z2.png" alt="子类2"></p><p><strong>具体代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CookTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义步骤为抽象方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">ComplateCook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做菜～"</span>);</span><br><span class="line">        wash();</span><br><span class="line">        cook();</span><br><span class="line">        finish();</span><br><span class="line">        System.out.println(<span class="string">"完成做菜步骤～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XihongshiChaoEgg</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"切西红柿，准备鸡蛋～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炒鸡蛋，然后再炒西红柿～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"西红柿炒蛋做好了，出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YuXiangRose</span> <span class="keyword">extends</span> <span class="title">CookTemplate</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"洗胡萝卜～"</span>);</span><br><span class="line">        System.out.println(<span class="string">"切肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cook</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始做鱼香肉丝～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鱼香肉丝做好了 出锅～"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CookTemplate cook = <span class="keyword">new</span> XihongshiChaoEgg();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">        cook = <span class="keyword">new</span> YuXiangRose();</span><br><span class="line">        cook.ComplateCook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模板方法模式优缺点"><a href="#模板方法模式优缺点" class="headerlink" title="模板方法模式优缺点"></a>模板方法模式优缺点</h4><ul><li><p>优点</p><ul><li>封装了不可变的部分，扩展可变部分</li><li>提供公共代码，便于维护</li><li>具体行为父类控制，子类只管自己的细节实现，符合开闭原则</li></ul></li><li><p>缺点</p><ul><li>一个不同的实现都要增加一个子类，会导致代码量很庞大</li><li>父类的执行结果会受到子类的影响，在复杂代码的阅读中会给开发人员带来很多麻烦</li></ul></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>模板方法模式适用于：有一个固定的算法步骤，但是细节实现存在多种可能的场景，即整体稳定但是个别易变的时候讲会变化的那一部分抽象出来。<br>模板方法模式强调抽象类与子类之间的协作，它将调用权交给父类，是一种控制反转的设计理念。子类不再去完成核心的功能，只需要关注属于自己的那一部分的实现。</p><hr><ul><li>JDK中经典的模板方法模式实现：<strong>AQS</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190707/【设计模式】模板方法模式/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="模板方法模式模式" scheme="http://zhangjiaheng.cn/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(六)：Exchanger的学习及使用场景</title>
    <link href="http://zhangjiaheng.cn/blog/20190701/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%85%AD-%EF%BC%9AExchanger%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://zhangjiaheng.cn/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/</id>
    <published>2019-07-01T13:28:39.000Z</published>
    <updated>2019-11-01T01:40:48.244Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。<br></p><p>Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(<strong>exchange方法</strong>)之后(<em>有一个没有执行到就一直等待，也可以设置等待超时时间</em>)，就将自身线程的数据与对方交换。</p><a id="more"></a><p><div style="text-align: center" center><a href="javascript:" target="_blank" rel="noopener">Exchanger工具类UML</a></div><br><img src="/blog/20190701/并发编程学习-六-：Exchanger的学习及使用场景/exc.png" alt="UML"></p><h4 id="Exchanger类结构"><a href="#Exchanger类结构" class="headerlink" title="Exchanger类结构"></a>Exchanger类结构</h4><p>如上图UNML，Exchanger类中有两个内部类，一个Node，一个Participant。</p><p>Participant继承了ThreadLocal并且重写了其initialValue方法，返回一个Node对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The corresponding thread local class */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">initialValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Node(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类封装了两个线程存储的数据对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Nodes hold partially exchanged data, plus other per-thread</span></span><br><span class="line"><span class="comment"> * bookkeeping. Padded via <span class="doctag">@sun</span>.misc.Contended to reduce memory</span></span><br><span class="line"><span class="comment"> * contention.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index;              <span class="comment">//  node 在 arena 数组下标</span></span><br><span class="line">    <span class="keyword">int</span> bound;              <span class="comment">//  交换器的最后记录值 </span></span><br><span class="line">    <span class="keyword">int</span> collides;           <span class="comment">//  记录的 CAS 失败数</span></span><br><span class="line">    <span class="keyword">int</span> hash;               <span class="comment">//  伪随机的自旋数</span></span><br><span class="line">    Object item;            <span class="comment">//  这个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Object match;  <span class="comment">//  另一个线程的数据项</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parked; <span class="comment">//  当阻塞时，设置此线程，不阻塞的话会自旋</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Exchanger源码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object v;</span><br><span class="line">    Object item = (x == <span class="keyword">null</span>) ? NULL_ITEM : x; <span class="comment">// translate null args</span></span><br><span class="line">    <span class="keyword">if</span> ((arena != <span class="keyword">null</span> || <span class="comment">// 是null就执行后面的方法</span></span><br><span class="line">         (v = slotExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">        <span class="comment">// 如果执行slotExchange有结果就执行后面的，否则返回</span></span><br><span class="line">        ((Thread.interrupted() || <span class="comment">// 非中断则执行后面的方法</span></span><br><span class="line">          (v = arenaExchange(item, <span class="keyword">false</span>, <span class="number">0L</span>)) == <span class="keyword">null</span>)))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> (v == NULL_ITEM) ? <span class="keyword">null</span> : (V)v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>exchange</code>方法的步骤：</p><ul><li>如果执行slotExchange有结果就执行后面的arenaExchange</li><li>如果solt被占用，就执行arenaExchange</li><li>返回的数据v是对方线程的数据项</li><li>总结即：如果A线程先调用，那么A的数据项存储的item中</li><li>则B线程的数据项存储在match中</li><li>当没有多线程并发操作 Exchange 的时候，使用 slotExchange 就足够了。 slot 是一个 node 对象。</li><li>当出现并发了，一个 slot 就不够了，就需要使用一个 node 数组 arena 操作了。</li></ul><p>​    </p><h4 id="Exchanger的使用"><a href="#Exchanger的使用" class="headerlink" title="Exchanger的使用"></a>Exchanger的使用</h4><p>下面的例子模拟一个队列中数据的交换使用的场景：</p><ul><li>线程A往队列中存入数据</li><li>线程B从队列中消耗数据</li><li>当线程A存满的时候</li><li>才交换给线程B</li><li>当线程B消耗完成之后才交换给线程A。</li><li>线程A、B的生产和消耗的速率有可能不同</li><li>对方线程调用exchange之前，另一个线程执行到exchange会阻塞</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在对方线程调用exchange之前，另一个线程执行到exchange会阻塞 直到双方都调用exchange */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialFillQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ArrayBlockingQueue&lt;String&gt; initialEmptyQueue </span><br><span class="line">      = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Exchanger&lt;ArrayBlockingQueue&lt;String&gt;&gt; exchanger </span><br><span class="line">      = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FillingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialEmptyQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          String str = StrUtil.uuid();</span><br><span class="line">          System.out.println(<span class="string">"生产了一个序列："</span> + str + <span class="string">"&gt;&gt;&gt;&gt;&gt;加入到交换区"</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            current.add(str);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列已满，换一个空的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/** 填充缓存队列的线程 */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EmptyingRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ArrayBlockingQueue&lt;String&gt; current = initialFillQueue;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!current.isEmpty()) &#123;</span><br><span class="line">            String str = current.poll();</span><br><span class="line">            System.out.println(<span class="string">"消耗一个数列："</span> + str);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"队列空了，换个满的"</span>);</span><br><span class="line">            current = exchanger.exchange(current);</span><br><span class="line">            System.out.println(<span class="string">"换满的成功~~~~~~~~~~~~~~~~~~~~~~"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> FillingRunnable()).start();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> EmptyingRunnable()).start();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><blockquote><p><a href="https://juejin.im/post/5ae7554ff265da0b86360880" target="_blank" rel="noopener">&gt;&gt;&gt;&gt;&gt; 更详细的源码解析 - 掘金</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/5/1/16317a536c642f7c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="结尾"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;在JUC包中，除了一些常用的或者说常见的并发工具类(ReentrantLock，CountDownLatch，CyclicBarrier，Semaphore)等，还有一个不常用的线程同步器类 —— Exchanger。&lt;br&gt;&lt;/p&gt;
&lt;p&gt;Exchanger是适用在两个线程之间数据交换的并发工具类，它的作用是找到一个同步点，当两个线程都执行到了同步点(&lt;strong&gt;exchange方法&lt;/strong&gt;)之后(&lt;em&gt;有一个没有执行到就一直等待，也可以设置等待超时时间&lt;/em&gt;)，就将自身线程的数据与对方交换。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Exchanger" scheme="http://zhangjiaheng.cn/tags/Exchanger/"/>
    
      <category term="线程交换器" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%8D%A2%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(五)：Semaphore源码学习及使用案例</title>
    <link href="http://zhangjiaheng.cn/blog/20190623/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%BA%94-%EF%BC%9ASemaphore%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/</id>
    <published>2019-06-23T12:27:19.000Z</published>
    <updated>2019-11-01T01:40:48.241Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png" alt></p><a id="more"></a><h3 id="Semaphore同步工具类之信号量介绍"><a href="#Semaphore同步工具类之信号量介绍" class="headerlink" title="Semaphore同步工具类之信号量介绍"></a>Semaphore同步工具类之信号量介绍</h3><h4 id="什么是Semaphore"><a href="#什么是Semaphore" class="headerlink" title="什么是Semaphore"></a>什么是Semaphore</h4><ul><li>Semaphore是JUC包中的一个很简单的工具类，用来实现多线程下对于资源的同一时刻的访问线程数限制</li><li>Semaphore中存在一个【许可】的概念，即访问资源之前，先要获得许可，如果当前许可数量为0，那么线程阻塞，直到获得许可</li><li>Semaphore内部使用AQS实现，由抽象内部类Sync继承了AQS。因为Semaphore天生就是共享的场景，所以其内部实际上类似于共享锁的实现。</li><li>Semaphore机制是提供给线程抢占式获取许可，所以他可以实现公平或者非公平，类似于ReentrantLock。</li><li>Semaphore提供两个构造方法，用来传入许可数量以及公平或者非公平：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Semaphore的使用场景"><a href="#Semaphore的使用场景" class="headerlink" title="Semaphore的使用场景"></a>Semaphore的使用场景</h4><ul><li>限流：并发环境(例如有1000个线程)下只允许100个线程访问数据库某资源</li><li>亦例如实际的，停车场只有10个车位，目前有15个汽车要来停车，多出的5个需要等其他车辆离开之后才能进行停车</li></ul><h3 id="Semaphore源码解读"><a href="#Semaphore源码解读" class="headerlink" title="Semaphore源码解读"></a>Semaphore源码解读</h3><p>分为公平与非公平</p><h4 id="获取许可的非公平的实现"><a href="#获取许可的非公平的实现" class="headerlink" title="获取许可的非公平的实现"></a>获取许可的非公平的实现</h4><p>在抽象类Sync中实现了非公平的消耗“许可”的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">        compareAndSetState(available, remaining))</span><br><span class="line">        <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><p>首先获取当前许可数量</p></li><li><p>判断消耗许可之后的剩余数量是否&gt;=0</p></li><li><p>是的话执行<code>compareAndSetState(available, remaining)</code>设置许可之后返回</p></li><li><p>否则返回的负数会使得其在<code>doAcquireSharedInterruptibly</code>中等待许可并挂起，直到被唤醒(这步骤在AQS中实现，如下)</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果线程被中断了，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//获取许可失败，将线程加入到等待队列中</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">    doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取许可的公平实现"><a href="#获取许可的公平实现" class="headerlink" title="获取许可的公平实现"></a>获取许可的公平实现</h4><p>首先会在获取许可之前，判断<code>hasQueuedPredecessors()</code>，是否有线程在等待队列中等待许可，有的话直接返回-1，这个底层实现在AQS中已经实现好了。接下来剩下的操作就和非公平的基本一致了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">    FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="comment">// 判断头节点不等于尾节点并且（头节点的下一节点为空或者其为当前线程）</span></span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="许可的释放"><a href="#许可的释放" class="headerlink" title="许可的释放"></a>许可的释放</h4><p>许可的释放对于公平和非公平的实现都是一致的，定义在Sync类中。因为是共享式的，释放的时候没有像ReentrantLock一样去判断是否是当前线程来释放许可。释放许可也是采用原子操作将需要释放的许可加回去就完成了。</p><p>一旦线程调用<code>releaseShared</code>释放许可成功，就会同时调用<code>doReleaseShared</code>方法，其中会对阻塞的线程进行环型，下面是<code>tryReleaseShared</code>的源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到当前的许可数量</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">// 加上还回来的许可</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 原子操作 归还许可</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="减少许可数量以及将剩余许可数量都取走"><a href="#减少许可数量以及将剩余许可数量都取走" class="headerlink" title="减少许可数量以及将剩余许可数量都取走"></a>减少许可数量以及将剩余许可数量都取走</h4><p>Semaphore还提供了几个额外的操作许可的方法</p><ul><li><p>减少许可数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">        <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>取走剩余全部许可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实际使用信号量的代码实例"><a href="#实际使用信号量的代码实例" class="headerlink" title="实际使用信号量的代码实例"></a>实际使用信号量的代码实例</h3><p>如下：使用信号量做了一个限流的功能。</p><p>在1000个线程并发访问的情况下，每次限制只有100个线程能够获取到资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreStudy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 许可的数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// 线程数量</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> M = <span class="number">1000</span>;</span><br><span class="line">  <span class="comment">// 获取许可失败的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger F = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 获取许可成功的次数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger S = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">  <span class="comment">// 声明许可</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Semaphore store = <span class="keyword">new</span> Semaphore(N);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 使用栅栏模拟1000并发</span></span><br><span class="line">    CyclicBarrier BARRIER = <span class="keyword">new</span> CyclicBarrier(M + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 使用线程池创建线程</span></span><br><span class="line">    ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">      pool.execute(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              BARRIER.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            getData();</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"等待2秒执行并发1000线程"</span>);</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="comment">// 等待两秒后打开栅栏 并发获取数据开始执行</span></span><br><span class="line">    BARRIER.await();</span><br><span class="line">    pool.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** 模拟获取数据或者业务处理 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!store.tryAcquire()) &#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">5000</span> + <span class="keyword">new</span> Random().nextInt(<span class="number">1000</span>);</span><br><span class="line">      System.out.println(<span class="string">"没有可用资源，等待一小会儿: "</span> + a + <span class="string">"，目前："</span> + F.incrementAndGet());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(a);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"成功拿到资源"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    store.release();</span><br><span class="line">    System.out.println(<span class="string">"释放资源，现在："</span> + S.incrementAndGet());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190623/并发编程学习-五-：Semaphore源码学习及使用案例/fm.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Semaphore" scheme="http://zhangjiaheng.cn/tags/Semaphore/"/>
    
      <category term="信号量" scheme="http://zhangjiaheng.cn/tags/%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(四)：理解ThreadPoolExecutor线程池</title>
    <link href="http://zhangjiaheng.cn/blog/20190617/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%EF%BC%9A%E7%90%86%E8%A7%A3ThreadPoolExecutor%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://zhangjiaheng.cn/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/</id>
    <published>2019-06-17T06:19:07.000Z</published>
    <updated>2019-11-01T01:40:48.245Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png" alt="线程池"></p><a id="more"></a><h3 id="前言：关于ThreadPoolExecutor"><a href="#前言：关于ThreadPoolExecutor" class="headerlink" title="前言：关于ThreadPoolExecutor"></a>前言：关于ThreadPoolExecutor</h3><p><strong>ThreadPoolExecutor</strong>即我们常说的线程池。《阿里巴巴Java手册》中对于线程池的使用规定如下：</p><blockquote><p><strong>3.【强制】线程资源必须通过线程池提供，不允许在应用中自行显示创建线程。</strong><br><br><strong>说明：使用线程池的好处是减少线程在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量的同类线程而导致消耗完内存或者“过度切换”的问题​</strong></p></blockquote><h3 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h3><h4 id="使用线程池创建线程可以"><a href="#使用线程池创建线程可以" class="headerlink" title="使用线程池创建线程可以"></a>使用线程池创建线程可以</h4><ul><li>避免在应用中频繁的创建和销毁线程</li><li>使用线程池创建线程可以复用CPU资源</li><li>提高线程的可管理性</li></ul><h3 id="使用线程池的风险"><a href="#使用线程池的风险" class="headerlink" title="使用线程池的风险"></a>使用线程池的风险</h3><h4 id="线程饥饿死锁"><a href="#线程饥饿死锁" class="headerlink" title="线程饥饿死锁"></a>线程饥饿死锁</h4><p>线程池为“死锁”这一概念带来了一种新的可能：线程饥饿死锁。在线程池中，如果一个任务将另一个任务提交到同一个Executor，那么通常会引发死锁。第二个线程停留在工作队列中等待第一个提交的任务执行完成，但是第一个任务又无法执行完成，因为它在等待第二个任务执行完成。如下代码所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class MyThreadPoolDeadLock &#123;</span><br><span class="line">    static ExecutorService singlePool = Executors.newSingleThreadExecutor();</span><br><span class="line">    static class MyTask implements Callable&lt;String&gt; &#123;</span><br><span class="line">        String name;</span><br><span class="line">        public MyTask(String name) &#123;</span><br><span class="line">            this.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public String call() throws Exception &#123;</span><br><span class="line">            Future&lt;String&gt; inner = singlePool.submit(new MyTask(&quot;inner&quot;));</span><br><span class="line">            return inner.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;</span><br><span class="line">        Future&lt;String&gt; result = singlePool.submit(new MyTask(&quot;outer&quot;));</span><br><span class="line">        System.out.println(result.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在更大的线程池中，如果所有线程都由于等待其他仍处于工作队列的任务而阻塞，那么会发生同样的问题，这种情况被称为线程饥饿死锁。</p><h4 id="内存溢出"><a href="#内存溢出" class="headerlink" title="内存溢出"></a>内存溢出</h4><p>除了Thread 对象所需的内存之外，每个线程都需要两个可能很大的执行调用堆栈。除此以外，JVM 可能会为每个 Java 线程创建一个本机线程，这些本机线程将消耗额外的系统资源。如果线程池的大小设置的不合理就会有可能导致内存溢出的风险。还有就是Java预置线程池FixedThreadPool 和 SingleThreadPool中的阻塞队列使用的无界队列，最多可以保存2147483647个任务，如果代码编写不严谨就会堆积大量请求导致内存溢出。</p><h4 id="线程泄漏"><a href="#线程泄漏" class="headerlink" title="线程泄漏"></a>线程泄漏</h4><p>各种线程池都会导致一种问题就是线程泄漏。当从线程池取出一个线程去执行任务时，如果任务抛出RuntimeException 或一个Error而未捕获异常时，那么线程只会退出而线程池的大小将永远减少一个，当这种情况发生多次时，线程池最终就会为空并且因为没有可用的线程来处理任务。</p><h3 id="如果要自己实现线程池需要关注哪些点"><a href="#如果要自己实现线程池需要关注哪些点" class="headerlink" title="如果要自己实现线程池需要关注哪些点"></a>如果要自己实现线程池需要关注哪些点</h3><ul><li>首先要有一个存放线程的容器并设置容量</li><li>还需要一个存放用户提交的任务的容器，阻塞队列，有界还是无界</li><li>线程池创建的时候需要将指定数量的线程启动</li><li>用户提交任务的时候如果线程池没有空闲的线程如何创建线程并放入线程池</li><li>线程数量远大于用户提交的任务数量需要有一个回收线程的机制</li><li>线程全部在执行任务的时候存放的任务需要等待还是怎样或者再新加入任务时要提供一个饱和策略</li></ul><h3 id="ThreadPoolExecutor构造函数参数意义"><a href="#ThreadPoolExecutor构造函数参数意义" class="headerlink" title="ThreadPoolExecutor构造函数参数意义"></a>ThreadPoolExecutor构造函数参数意义</h3><p><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/gzhs.png" alt="构造函数"><br>ThreadPoolExecutor提供了四种构造函数，总共有如下几种参数，意义为：</p><ul><li><code>int corePoolSize</code>: 核心线程数的大小，在线程池创建的时候就会创建这么多线程待命，用户提交任务之后立即开始执行任务</li><li><code>int maximumPoolSize</code>: 最大线程数的大小，即最多会创建这么多线程，当超过这个数目的时候可能会在执行完任务之后回收多于核心线程数的线程</li><li><code>long keepAliveTime</code>: 线程最大存活时间，是相对于核心线程数来讲的。没有超过核心线程数的会一直存活的。超过的才有存活时间的限制</li><li><code>TimeUnit unit</code>: 时间单位</li><li><code>BlockingQueue&lt;Runnable&gt; workQueue</code>: 阻塞队列，用于存放用户提交的任务。系统预置的线程池的阻塞队列一般都是无界的LinkBlockingQueue，但是建议使用有界队列，对于非常大或者无界的线程池，可以使用同步移交队列控制避免排队，直接将任务从生产者移交到工作者线程。</li><li><code>ThreadFactory threadFactory</code>: 线程工厂接口。只有一个newThread方法。便于用户根据业务需要实现自己的线程创建机制。</li><li><code>RejectedExecutionHandler handler</code>: 饱和策略。默认四种，在下面讲解。</li></ul><h3 id="几种默认的饱和策略"><a href="#几种默认的饱和策略" class="headerlink" title="几种默认的饱和策略"></a>几种默认的饱和策略</h3><p>当有界队列被填满后，用户创建的任务无法再添加到线程池中保存，饱和策略开始发挥作用。如果某个任务被提交到已关闭的Executors时，饱和策略也会被执行。饱和策略的实现需要实现接口<code>RejectedExecutionHandler</code>。<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/bhcl.png" alt="四种默认的饱和策略"><br>如上，在ThreadPoolExecutor类中有四个内部类实现了<code>RejectedExecutionHandler</code>接口。分别是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static class AbortPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br><span class="line">public static class CallerRunsPolicy implements RejectedExecutionHandler &#123;...&#125;</span><br></pre></td></tr></table></figure></p><h4 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h4><p>“中止”策略是默认的饱和策略，该策略将会抛出一个异常<code>RejectedExecutionException</code>，调用者可以捕获这个异常然后编写自己的业务代码。</p><h4 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h4><p>“抛弃”策略会在新提交的任务无法保存在队列中等待执行时将其抛弃掉。</p><h4 id="DiscardOldestPolicy"><a href="#DiscardOldestPolicy" class="headerlink" title="DiscardOldestPolicy"></a>DiscardOldestPolicy</h4><p>同“抛弃”策略，这种策略会将即将执行的那个任务抛弃掉，即抛弃最老的任务然后尝试提交新的任务。如果工作队列使用的是优先队列，那么会导致优先级最高的任务被抛弃，<strong>慎用</strong>！</p><h4 id="CallerRunsPolicy"><a href="#CallerRunsPolicy" class="headerlink" title="CallerRunsPolicy"></a>CallerRunsPolicy</h4><p>“调用者执行”策略即在队列满的时候由调用者去执行该任务。不会在线程池的某个线程中执行新的任务。</p><blockquote><p>《阿里巴巴Java开发手册》中强调使用线程池的时候尽量使用ThreadPoolExecutor，目的在于让程序员更加明确线程池的工作机制，实际业务中不可能在任务满时将任务抛弃掉，所以实现自己的饱和策略是有必要的。</p></blockquote><h3 id="Java预置线程池及其使用场景"><a href="#Java预置线程池及其使用场景" class="headerlink" title="Java预置线程池及其使用场景"></a>Java预置线程池及其使用场景</h3><p>如图是Executors类中的所有方法<br><img src="/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/yzxcgz.png" alt="预置线程池构造"></p><h4 id="Executors-newCachedThreadPool"><a href="#Executors-newCachedThreadPool" class="headerlink" title="Executors.newCachedThreadPool()"></a>Executors.newCachedThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                              <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                              <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无限容量的线程池(最大为2147483647)，调用ThreadPoolExecutor构造传入的核心线程数为0。适合场景为创建执行时间短效快速的线程任务，线程在执行完成之后直接被回收。阻塞队列使用SynchronousQueue，这是一个不保存数据的队列，因为该线程池有任务提交就会创建线程去执行，所以不需要保存</p><h4 id="Executors-newFixedThreadPool-nThreads"><a href="#Executors-newFixedThreadPool-nThreads" class="headerlink" title="Executors.newFixedThreadPool(nThreads)"></a>Executors.newFixedThreadPool(nThreads)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建固定数量的线程池。调用ThreadPoolExecutor的构造函数传入的核心线程数等于最大线程数。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。</p><h4 id="Executors-newSingleThreadExecutor-："><a href="#Executors-newSingleThreadExecutor-：" class="headerlink" title="Executors.newSingleThreadExecutor()："></a>Executors.newSingleThreadExecutor()：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次都只有一个线程去执行任务，用户提交的任务都会排队阻塞在阻塞队列中等待上一个任务执行完之后执行下一个。适用场景为后面任务依赖前面任务的情况。该线程池中的阻塞队列也使用的是无界的LinkedBlockingQueue。使用这个线程池需要小心<a href="#线程饥饿死锁">线程饥饿死锁</a></p><h4 id="Executors-newWorkStealingPool"><a href="#Executors-newWorkStealingPool" class="headerlink" title="Executors.newWorkStealingPool()"></a>Executors.newWorkStealingPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取当前可用的线程数量进行创建作为并行级别，通过源码可以看出底层调用的是ForkJoinPool线程池，newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中。</p><h4 id="Executors-newScheduledThreadPool"><a href="#Executors-newScheduledThreadPool" class="headerlink" title="Executors.newScheduledThreadPool()"></a>Executors.newScheduledThreadPool()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line">↑↑↑</span><br><span class="line">↓↓↓</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">ScheduledExecutorService</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">              <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设定延迟时间，定期执行。通过源码可以看出底层调用的是一个ScheduledThreadPoolExecutor，然后传入线程数量。同newWorkStealingPool一样也不是直接使用ThreadPoolExecutor进行扩展。可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</p><h3 id="优雅的关闭线程池"><a href="#优雅的关闭线程池" class="headerlink" title="优雅的关闭线程池"></a>优雅的关闭线程池</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>设置线程池状态为关闭，但是只会关闭已经执行完成的线程，对于还未执行完成的线程，会等待执行完成再关闭。</p><p>当我们使用shuwdown方法关闭线程池时，一定要确保任务里不会有永久阻塞等待的逻辑，否则线程池就关闭不了。</p><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p>立马关闭线程池，线程池里的任务不再执行。</p><p>如果我们调用shutdownNow方法时，线程处于从队列里读取任务而阻塞中，则会导致抛出InterruptedException异常</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190617/并发编程学习-四-：理解ThreadPoolExecutor线程池/xcc.png&quot; alt=&quot;线程池&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="线程池" scheme="http://zhangjiaheng.cn/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://zhangjiaheng.cn/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的几种非递归遍历</title>
    <link href="http://zhangjiaheng.cn/blog/20190613/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%87%A0%E7%A7%8D%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"/>
    <id>http://zhangjiaheng.cn/blog/20190613/二叉树的几种非递归遍历/</id>
    <published>2019-06-13T09:36:48.000Z</published>
    <updated>2019-11-01T01:40:48.210Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190613/二叉树的几种非递归遍历/fm.jpg" alt="封面"></p><a id="more"></a><h2 id="二叉树的几种非递归遍历解法"><a href="#二叉树的几种非递归遍历解法" class="headerlink" title="二叉树的几种非递归遍历解法"></a>二叉树的几种非递归遍历解法</h2><p>二叉树的递归遍历想必了解递归以及二叉树的同学都能够轻松写出正确答案，然而二叉树的非递归遍历确是很多人难以理解学会的，所以我在这里进行一下归纳总结，主要是复习巩固一下这方面的知识。</p><h3 id="非递归先序遍历"><a href="#非递归先序遍历" class="headerlink" title="非递归先序遍历"></a>非递归先序遍历</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果弹出元素的右子树不为空则入栈</li><li>如果弹出元素的左子树不为空则入栈</li><li>继续循环</li></ul><p>解析：由于先序遍历为[根-左-右]，所以根节点应该先入栈，然后出栈的同时依次入栈右-左子树即可。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frontPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归中序遍历"><a href="#非递归中序遍历" class="headerlink" title="非递归中序遍历"></a>非递归中序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>首先将根节点入栈</li><li>循环判断根节点是否有左子树，有则入栈继续循环，否则循环结束</li><li>然后循环判断栈不为空</li><li>则弹出栈顶元素</li><li>如果栈顶元素右子树不为空</li><li>则循环入栈右子树及其右子树的左子树</li><li>继续循环</li></ul><p>解析：因为中序遍历为[左-根-又]，所以树的左子树应该先入栈，循环入栈左子树之后循环出栈，出栈的同时判断出栈元素是否有右子树，如果右子树不为空则对右子树执行相同的操作，即入栈右子树的左子树。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">midPrintByLoop</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode node = root;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            node = stack.pop();</span><br><span class="line">            TreeNode n = node.right;</span><br><span class="line">            <span class="keyword">while</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stack.push(n);</span><br><span class="line">                n = n.left;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非递归后序遍历"><a href="#非递归后序遍历" class="headerlink" title="非递归后序遍历"></a>非递归后序遍历</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路 1"></a>思路 1</h4><ul><li>逆向思考先序遍历，因为后序遍历为[根-左-右]，我们可以以类似先序遍历的方式先将[右-左-根]的顺序找出来存入另一个栈，然后再依次出栈该栈元素即可</li></ul><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码 1"></a>代码 1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOtherStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> Stack&lt;TreeNode&gt; stackReverse = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">                stackReverse.push(node);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(node.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!stackReverse.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stackReverse.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路 2"></a>思路 2</h4><ul><li>只使用一个栈</li><li>先将根节点入栈</li><li>设置一个标识引用 h首先指向root</li><li>循环判断栈非空</li><li>在循环中判断栈顶元素node</li><li>如果node左子树不为空并且左右子树都不为h指向的元素</li><li>入栈左子树</li><li>否则再判断右子树是否为空以及右子树是否为h节点</li><li>入栈右子树</li><li>否则，弹出栈顶元素，并且将h指向该弹出的栈顶元素</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码 2"></a>代码 2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lastPrintByOneStack</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        TreeNode h = root;</span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(h);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            TreeNode node = stack.peek();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span> &amp;&amp; node.left != h &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != node.right &amp;&amp; node.right != h) &#123;</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node = stack.pop();</span><br><span class="line">                System.out.print(node.val + <span class="string">" | "</span>);</span><br><span class="line">                h = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析：使用一个栈进行后序遍历的时候需要使用一个h引用来标识上一个节点是否被遍历过，是的话就往上判断之后的树节点即可。</p><h3 id="按层遍历二叉树"><a href="#按层遍历二叉树" class="headerlink" title="按层遍历二叉树"></a>按层遍历二叉树</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>以上前中后序遍历二叉树都是用到了栈这种数据结构，而按层遍历二叉树就非常简单了，只需要引入先入先出的队列，然后依次在出队的时候将出队元素的左右子树入队即可。</p><ul><li>根节点入队</li><li>队列不为空则开始循环</li><li>如果队首元素左子树不为空，就入队</li><li>右子树不为空，也入队</li><li>队首元素出队输出</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">levelPrintOutTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != root) &#123;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        TreeNode i = root;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(i.right);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(i.val + <span class="string">" | "</span>);</span><br><span class="line">            queue.poll();</span><br><span class="line">            i = queue.peek();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190613/二叉树的几种非递归遍历/fm.jpg&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    
      <category term="数据结构与算法" scheme="http://zhangjiaheng.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="二叉树" scheme="http://zhangjiaheng.cn/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>深度分析如何写出一个线程安全的单例</title>
    <link href="http://zhangjiaheng.cn/blog/20190607/%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B/"/>
    <id>http://zhangjiaheng.cn/blog/20190607/深度分析如何写出一个线程安全的单例/</id>
    <published>2019-06-07T12:51:33.000Z</published>
    <updated>2019-11-01T01:40:48.257Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png" alt="封面"></p><a id="more"></a><h3 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h3><p>单例模式是在Java编程中除了工厂模式之外最常用的创建型设计模式之一。单例模式提供了一种创建对象的方式，使得每次获取到的该类的实例都是同一个。即所谓的提供了访问该类实例的唯一途径。</p><p><strong>单例模式在创建时的注意事项：</strong></p><ul><li>因为每个类只能创建一个实例，所以需要将其构造方法封闭起来不能被外部调用，即私有化；</li><li>需要提供一个获取类实例的公有方法，所有使用该类实例的人都通过这个方法拿到单例对象；</li><li>在多线程环境下需要注意线程安全问题，避免多个线程同时创建出多个不同的实例，违背了单例的原则。</li></ul><h3 id="创建单例模式的方法及其优缺点"><a href="#创建单例模式的方法及其优缺点" class="headerlink" title="创建单例模式的方法及其优缺点"></a>创建单例模式的方法及其优缺点</h3><h4 id="饿汉型"><a href="#饿汉型" class="headerlink" title="饿汉型"></a>饿汉型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取类在加载的时候就创建好的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：饿汉型单例是最简单的单例创建方法，在类中维护一个该类私有不可变的实例，然后提供一个获取该实例的静态方法即可。</li><li>优点：代码编写简单，线程安全（使用类加载机制保证线程安全，classloader在加载类的时候使用synchronized同步）</li><li>缺点：无法实现懒加载，在使用较少的时候浪费资源，无法防止反射破坏以及反序列化破坏单例唯一性</li></ul><h4 id="普通懒汉型"><a href="#普通懒汉型" class="headerlink" title="普通懒汉型"></a>普通懒汉型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton INSTANCE ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == INSTANCE)&#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：这种懒汉型单例也是一种比较简单的单例实现方式，与第一种不同在于这种实例是在调用获取实例的静态方法的时候才创建</li><li>优点：代码简单，可以实现懒加载</li><li>缺点：多线程环境下会有线程安全问题，多个线程同时走到第8行代码，判断实例未创建，则会创建出多个实例;无法防止反射破坏以及反序列化破坏</li></ul><p><em>那么为了实现线程安全我们可以在方法上加上同步关键字，但是这种方式的缺点就是多线程环境调用该方法都会阻塞，导致性能存在不必要的浪费</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == INSTANCE)&#123;</span><br><span class="line">INSTANCE = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="双重检测锁实现懒加载单例"><a href="#双重检测锁实现懒加载单例" class="headerlink" title="双重检测锁实现懒加载单例"></a>双重检测锁实现懒加载单例</h4><p>上述懒汉型同步机制可以改进如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleLockSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleLockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DoubleLockSingleton INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 进入方法后先判断一次 大幅减少多线程环境同步阻塞问题 </span></span><br><span class="line"><span class="comment">// 但是这种方式在多线程第一次调用创建实例的时候会出现线程安全问题</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleLockSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == INSTANCE) &#123;</span><br><span class="line"><span class="comment">// 问题的根源所在</span></span><br><span class="line"><span class="comment">// 此处可能会出现指令重排序 </span></span><br><span class="line"><span class="comment">// new对象并不是原子操作</span></span><br><span class="line">INSTANCE = <span class="keyword">new</span> DoubleLockSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：双重检测锁机制在进入<code>getInstance()</code>方法的时候会判断实例是否被创建，如果被创建，那么直接返回，如果没有，进入同步代码块，创建实例。这个方法貌似没有问题，而且还大大减少线程进入同步代码块阻塞的情况（因为只有第一次判断对象还没有创建的时候才会有线程进入同步代码块）。但是这种方法仍然存在线程安全性问题。<font color="#db1414">问题出在第17行：<code>INSTANCE = new DoubleLockSingleton();</code>由于JVM虚拟机内部会对代码进行优化，在使用new创建对象的时候并不是一个原子操作且会被虚拟机进行指令重排序。这个步骤会被分成三步：<strong>1、在堆上为对象分配空间；2、对象进行初始化；3、将引用指向该堆上的地址。 </strong>由于在虚拟机中，指令重排序优化导致第2步和第3步的执行顺序可以被打乱，那么在代码执行到第11行的时候发现，INSTANCE不为null，直接返回一个未初始化完成的对象，导致程序崩溃。</font><strong>注意：synchronzed关键字没有屏蔽指令重排序的功能</strong>，那么如何优化呢？答案是使用<code>volatile</code>关键字修饰实例变量引用，即<code>private volatile static TripleLockSingleton INSTANCE;</code>。<code>volatile</code>关键字才有屏蔽指令重排序的语义。</li><li>优点：多线程环境下大部分时间线程安全</li><li>缺点：有可能会出现线程安全问题；不能避免反射和反序列化破坏</li><li>优化：<code>private volatile static TripleLockSingleton INSTANCE;</code></li></ul><h4 id="静态内部类单例"><a href="#静态内部类单例" class="headerlink" title="静态内部类单例"></a>静态内部类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleton INSTANCE = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：静态内部类实现单例也是借助了类加载的线程安全机制，并同时基于内部类的使用时再创建的懒加载机制实现线程安全的懒加载模式的单例</li><li>优点：线程安全，可以实现懒加载</li><li>缺点：无法防止被反射以及反序列化破坏单例的唯一性</li></ul><h4 id="枚举类单例"><a href="#枚举类单例" class="headerlink" title="枚举类单例"></a>枚举类单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：<strong>Joshua Bloch</strong>大神说过：“单元素的枚举类型已经成为实现Singleton的最佳方法”。足以见证枚举类在创建单例中的优势。</li><li>优点：代码简单，线程安全，可以防止反射和反序列化破坏</li><li>缺点：暂无</li></ul><h4 id="CAS创建单例"><a href="#CAS创建单例" class="headerlink" title="CAS创建单例"></a>CAS创建单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReference&lt;CASSingleton&gt; INSTANCE = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CASSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用原子操作 实现获取唯一实例</span></span><br><span class="line"><span class="comment">     * 理论上在大量竞争的环境中 原子操作自旋等待消耗大量性能 但是实际上当一个线程创建好实例之后其余线程不会出现死循环</span></span><br><span class="line"><span class="comment">     * 相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CASSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            CASSingleton instance = INSTANCE.get();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != instance) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> CASSingleton();</span><br><span class="line">            <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, instance)) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分析：使用原子操作<code>AtomicReference</code>进行单例的创建，事实上目前相对于双重检查锁性能上差的也不是也别大</li><li>优点：线程安全，懒加载，相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度</li><li>缺点：代码编写相对复杂，不能防止被反射和反序列化破坏</li></ul><h3 id="防止反射和反序列化破坏单例的方式"><a href="#防止反射和反序列化破坏单例的方式" class="headerlink" title="防止反射和反序列化破坏单例的方式"></a>防止反射和反序列化破坏单例的方式</h3><p>上述几个创建单例的方式中，除了使用枚举类创建单例，都会产生被反射和反序列化破坏的情况，避免该问题的方式如下，大家需要深究的话可以打开搜索引擎… 这里不再展开了~</p><h4 id="枚举类防止反射和反序列化破坏"><a href="#枚举类防止反射和反序列化破坏" class="headerlink" title="枚举类防止反射和反序列化破坏"></a>枚举类防止反射和反序列化破坏</h4><blockquote><p><strong> 参考文章：<a href="https://www.cnblogs.com/chiclee/p/9097772.html" target="_blank" rel="noopener">https://www.cnblogs.com/chiclee/p/9097772.html</a> </strong></p></blockquote><h4 id="防止反射破坏"><a href="#防止反射破坏" class="headerlink" title="防止反射破坏"></a>防止反射破坏</h4><p>因为反射是通过class对象来调用类的构造方法创建对象的，我们只需要在构造方法中进行判断，如果实例已经存在，就抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私有构造</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(INSTANCE != <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="防止反序列化破坏"><a href="#防止反序列化破坏" class="headerlink" title="防止反序列化破坏"></a>防止反序列化破坏</h4><p>在反序列化的时候<code>ObjectInputStream.readObject()</code>中会去判断是否存在<code>readResolve()</code>方法，如果存在的话会调用该方法返回一个实例，所以在单例类中编写<code>readResolve()</code>方法返回<code>INSTANCE</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在反序列化时，直接调用这个方法，返回指定的对象，无需再新建一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190607/深度分析如何写出一个线程安全的单例/fm.png&quot; alt=&quot;封面&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="http://zhangjiaheng.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="http://zhangjiaheng.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>并发编程学习(三)：CountDownLatch的实现原理及使用</title>
    <link href="http://zhangjiaheng.cn/blog/20190602/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E4%B8%89-%EF%BC%9ACountDownLatch%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://zhangjiaheng.cn/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/</id>
    <published>2019-06-02T13:36:53.000Z</published>
    <updated>2019-11-01T01:40:48.239Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png" alt="什么是CountDownLatch？"></p><a id="more"></a><h3 id="什么是CountDownLatch？"><a href="#什么是CountDownLatch？" class="headerlink" title="什么是CountDownLatch？"></a>什么是<code>CountDownLatch</code>？</h3><p>  在本篇博客的封面，我放了一个截图，上面对于<code>CountDownLatch</code>的翻译是这样的：<em>闭锁，倒计时门闩</em>。其实顾名思义，<code>CountDownLatch</code>实际上就是一个计数器：<strong>计数-计数完成后做一些事</strong>。其实这个东西可以类比为一个水坝：当水还没有装满水库的时候水坝是关闭的，当水装满之后开闸放水，水库中的水”一起”涌出水库。</p><p>  拥有同样功能的还有<code>CyclicBarrier</code>这个类，但是这个类相对较复杂，并且相对于<code>CountDownLatch</code>还可以重复使用，实际上前者一般被叫做线程计数器，后者被叫做循环屏障，还是有很大区别的。这个 <strong>在后面再进行源码学习</strong>。</p><h3 id="CountDownLatch是如何实现的？"><a href="#CountDownLatch是如何实现的？" class="headerlink" title="CountDownLatch是如何实现的？"></a><code>CountDownLatch</code>是如何实现的？</h3><p>  同<code>ReentrantLock</code>类似，内部也是有一个实现了<code>AbstractQueueSynchronizer</code>的内部类。内部类做了父类的共享式的显示锁的方法实现，维护一个初始为N的状态<code>state</code>，每次有线程调用之后阻塞，然后<code>state</code>减1，直到减为0之后所有阻塞的线程重新开始执行。</p><h4 id="首先是内部类Sync的实现"><a href="#首先是内部类Sync的实现" class="headerlink" title="首先是内部类Sync的实现"></a>首先是内部类Sync的实现</h4><p>  构造器接收一个int参数初始化state的值。<code>tryAcquireShared()</code>方法不会对state做改变，当state不为0的时候返回-1即失败，当state等于0其返回1，表示计数器已经计数完成，<code>await()</code>方法不再阻塞。<code>tryReleaseShared()</code>方法会使用原子操作当<code>countDown()</code>被调用的时候释放一个state的占用，即state-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line">      Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">          setState(count);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> c = getState();</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                  <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的countDown方法"><a href="#CountDownLatch的countDown方法" class="headerlink" title="CountDownLatch的countDown方法"></a>CountDownLatch的countDown方法</h4><p>  countDown方法主要作用就是使state-1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>releaseShared()</code>方法的实现，如果释放成功执行<code>doReleaseShared();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CountDownLatch的await方法"><a href="#CountDownLatch的await方法" class="headerlink" title="CountDownLatch的await方法"></a>CountDownLatch的await方法</h4><p>  await方法会等待当前state值是否是0，如果不是的话就一直阻塞。直到state为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireSharedNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  AQS中的<code>acquireSharedInterruptibly()</code>方法实现如下，在AQS的实现中，判断当前线程是否中断，是的话抛出中断异常，否则判断当前线程是否继续需要阻塞，即调用<code>tryAcquireShared()</code>。是的话进入<code>doAcquireSharedInterruptibly()</code>方法，不断的判断<code>int r = tryAcquireShared(arg);</code>，state如果一直不等于0，r就一直是负数，就会继续进入循环。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Acquires in shared interruptible mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arg the acquire argument</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其实以上代码的整体流程非常简单，即初始化<code>CountDownLatch</code>的state=N，每次调用countDown时state-1，减到0的时候停止阻塞，继续向下执行。</p><h3 id="我可以用CountDownLatch来做什么事情？"><a href="#我可以用CountDownLatch来做什么事情？" class="headerlink" title="我可以用CountDownLatch来做什么事情？"></a>我可以用<code>CountDownLatch</code>来做什么事情？</h3><h4 id="使用CountDownLatch模拟并发场景"><a href="#使用CountDownLatch模拟并发场景" class="headerlink" title="使用CountDownLatch模拟并发场景"></a>使用<code>CountDownLatch</code>模拟并发场景</h4><ul><li>可以使用<code>CountDownLatch</code>，创建多个线程并等待线程全部就绪之后唤醒所有线程。可以用这种方式测试代码的可用性，或者测试单例类等；</li></ul><p>我在自己学习过程中也有写过类似的测试类 - <a href="https://github.com/Fatezhang/Concurrent/tree/master/src/main/java/com/mime/concurrent/CountDownLatchStudy" target="_blank" rel="noopener">github</a></p><h4 id="使用CountDownLatch等待依赖线程执行"><a href="#使用CountDownLatch等待依赖线程执行" class="headerlink" title="使用CountDownLatch等待依赖线程执行"></a>使用<code>CountDownLatch</code>等待依赖线程执行</h4><ul><li><code>CountDownLatch</code>用来等待其他依赖服务都启动好之后在进行自身线程的任务处理</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>  <code>CountDownLatch</code>是面试的时候多线程这块很容易被问到的点，实际上会考察这几个方面：</p><ul><li>1、内部实现原理 <strong>——</strong> 使用内部类继承AQS实现；</li><li>2、需要注意的方面 <strong>——</strong> 计数器为0时，await后面的方法才会执行，否则一直阻塞，countDown方法尽量写在finally代码块中，避免出现异常导致死锁；</li><li>3、使用场景 <strong>——</strong> 监控一些依赖服务启动完成之后执行代码，或者造“水坝”，即模拟大量并发场景等。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/blog/20190602/并发编程学习-三-：CountDownLatch的实现原理及使用/cdl.png&quot; alt=&quot;什么是CountDownLatch？&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/categories/Java%E5%9F%BA%E7%A1%80/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Java基础" scheme="http://zhangjiaheng.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="并发编程" scheme="http://zhangjiaheng.cn/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="AQS" scheme="http://zhangjiaheng.cn/tags/AQS/"/>
    
      <category term="CountDownLatch" scheme="http://zhangjiaheng.cn/tags/CountDownLatch/"/>
    
  </entry>
  
</feed>
